/*
 * $Id: ai.trm,v 1.17 1998/03/22 22:34:29 drd Exp $
 *
 */

/* GNUPLOT - ai.trm */

/*[
 * Copyright 1991, 1992, 1993, 1998
 *
 * Permission to use, copy, and distribute this software and its
 * documentation for any purpose with or without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.
 *
 * Permission to modify the software is granted, but not the right to
 * distribute the complete modified source code.  Modifications are to
 * be distributed as patches to the released version.  Permission to
 * distribute binaries produced by compiling modified sources is granted,
 * provided you
 *   1. distribute the corresponding source modifications from the
 *    released version in the form of a patch file along with the binaries,
 *   2. add special version identification to distinguish your version
 *    in addition to the base release version number,
 *   3. provide your name and address as the primary contact for the
 *    support of your modified version, and
 *   4. retain our contact information in regard to use of the base
 *    software.
 * Permission to distribute the released version of the source code along
 * with corresponding source modifications in the form of a patch file is
 * granted with same provisions 2 through 4 for binary distributions.
 *
 * This software is provided "as is" without express or implied warranty
 * to the extent permitted by applicable law.
]*/

/*
 * This file is included by ../term.c.
 *
 * This terminal driver supports:
 *     aifm
 *
 * AUTHORS
 *  Ray Ghanbari
 * 
 * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
 *
 * The 'aifm' driver produces files editable by Adobe Illustrator 3.0
 * To change font to Courier and font size to 20pts use 
 * 'set term aifm "Courier" 20'.
 * To switch to color output use
 * 'set term aifm color'.
 */
 
 /* AIFM driver by Ray Ghanbari, ray@mtl.mit.edu, 
 *	based on PostScript driver by Russell Lang, rjl@monu1.cc.monash.edu.au */
 
/* Changed to 3.6 terminal format, David C. Schooley, 9/29/95 */
/* Improved multiple plot support, David C. Schooley, 6/5/95 */
/* Compatiblity with Illustrator 7.0, David C. Schooley, 6/5/95 */
/* Font and size support for labels, David C. Schooley, 6/5/95 */

#include "driver.h"

#ifdef TERM_REGISTER
register_term(aifm)
#endif

#ifdef TERM_PROTO
TERM_PUBLIC void AI_init __PROTO((void));
TERM_PUBLIC void AI_graphics __PROTO((void));
TERM_PUBLIC void AI_text __PROTO((void));
TERM_PUBLIC void AI_linetype __PROTO((int linetype));
TERM_PUBLIC void AI_move __PROTO((unsigned int x, unsigned int y));
TERM_PUBLIC void AI_vector __PROTO((unsigned int x, unsigned int y));
TERM_PUBLIC void AI_put_text __PROTO((unsigned int x, unsigned int y, char *str));
TERM_PUBLIC int AI_text_angle __PROTO((int ang));
TERM_PUBLIC void AI_reset __PROTO((void));
TERM_PUBLIC void AI_options __PROTO((void));
TERM_PUBLIC int AI_justify_text __PROTO((enum JUSTIFY mode));
TERM_PUBLIC void AI_suspend __PROTO(());
TERM_PUBLIC void AI_resume __PROTO(());
TERM_PUBLIC int AI_set_font __PROTO((char * font));

#define AI_XOFF	50	/* page offset in pts */
#define AI_YOFF	50

#define AI_XMAX 5000
#define AI_YMAX 3500

#define AI_XLAST (AI_XMAX - 1)
#define AI_YLAST (AI_YMAX - 1)

#define AI_VTIC (AI_YMAX/80)
#define AI_HTIC (AI_YMAX/80)

#define AI_SC (10.0)				/* scale is 1pt = 10 units */
#define AI_LW (0.5*AI_SC)		/* linewidth = 0.5 pts */

#define AI_VCHAR (14*AI_SC)		/* default is 14 point characters */
#define AI_HCHAR (14*AI_SC*6/10)

#endif



#ifndef TERM_PROTO_ONLY
#ifdef TERM_BODY

char ai_font[MAX_ID_LEN+1] = "Times-Roman" ; /* name of font */
int ai_fontsize = 14;					 /* size of font in pts */
char ai_oldfont[MAX_ID_LEN+1] = "Times-Roman" ; /* name of font */
int ai_oldfontsize = 14;					 /* size of font in pts */
TBOOLEAN ai_color = FALSE;
TBOOLEAN ai_stroke = FALSE;
int ai_page=0;			/* page count */
int ai_path_count=0; 	/* count of lines in path */
int ai_ang=0;			/* text angle */
int ai_subgroup_level=0; /* depth of sub-groups */
int ai_multiplot_group=0; /* group for multiplot */
enum JUSTIFY ai_justify=LEFT;	/* text is flush left */


TERM_PUBLIC void AI_options()
{
	if (!END_OF_COMMAND) {
		if (almost_equals(c_token,"d$efault")) {
			ai_color=FALSE;
			strcpy(ai_font,"Times-Roman");
			ai_fontsize = 14;
			strcpy(ai_oldfont,"Times-Roman");
			ai_oldfontsize = 14;
			c_token++;
		}
	}

	if (!END_OF_COMMAND) {
		if (almost_equals(c_token,"m$onochrome")) {
			ai_color=FALSE;
			c_token++;
		}
		else if (almost_equals(c_token,"c$olor")) {
			ai_color=TRUE;
			c_token++;
		}
	}

	if (!END_OF_COMMAND && isstring(c_token)) {
		quote_str(ai_font,c_token, MAX_ID_LEN);
		strcpy(ai_oldfont, ai_font);
		c_token++;
	}

	if (!END_OF_COMMAND) {
		/* We have font size specified */
		struct value a;
		ai_fontsize = (int)real(const_express(&a));
		ai_oldfontsize = ai_fontsize;
		c_token++;
		term->v_char = (unsigned int)(ai_fontsize*AI_SC);
		term->h_char = (unsigned int)(ai_fontsize*AI_SC*6/10);
	}

	sprintf(term_options,"%s \"%s\" %d",
		ai_color ? "color" : "monochrome",ai_font,ai_fontsize);
}


TERM_PUBLIC void AI_init()
{
	ai_page = 0;
	fprintf(outfile,"%%!PS-Adobe-2.0 EPSF-1.2\n");
	fprintf(outfile,"%%%%Creator: Adobe Illustrator(TM) 3.2\n");
	fprintf(outfile,"%%%%TrueCreator: gnuplot 3.6 ai terminal\n");
	fprintf(outfile,"%%%%BoundingBox: %d %d %d %d\n", AI_XOFF,AI_YOFF,
		(int)((AI_XMAX)/AI_SC+0.5+AI_XOFF), 
		(int)((AI_YMAX)/AI_SC+0.5+AI_YOFF) );
	fprintf(outfile,"%%%%Template:\n");
	fprintf(outfile,"%%%%EndComments\n");
	fprintf(outfile,"%%%%EndProlog\n");
}


TERM_PUBLIC void AI_graphics()
{
	ai_page++;
/*	fprintf(outfile,"%%%%Page: %d %d\n",ai_page,ai_page);*/
	fprintf(outfile,"0 G\n");
	fprintf(outfile,"1 j\n");
	fprintf(outfile,"1 J\n");
	fprintf(outfile,"u\n");
	ai_path_count = 0;
	ai_stroke = FALSE;
}


TERM_PUBLIC void AI_text()
{
	if (ai_stroke) {
		fprintf(outfile,"S\n");
		ai_stroke = FALSE;
	}
	while (ai_subgroup_level) {
		fprintf(outfile,"U\n");
		ai_subgroup_level--;
	}
	fprintf(outfile,"U\n");
	ai_path_count = 0;
	ai_multiplot_group = 0;
}


TERM_PUBLIC void AI_reset()
{
	fprintf(outfile,"%%%%Trailer\n");
/*	fprintf(outfile,"%%%%Pages: %d\n",ai_page);*/
}


TERM_PUBLIC void AI_linetype(linetype)
int linetype;
{
	if (ai_stroke) {
		fprintf(outfile,"S\n");
		ai_stroke = FALSE;
	}
	if (ai_subgroup_level) {
		fprintf(outfile,"U\n");
		ai_subgroup_level--;
	}
	if (linetype == -2 && multiplot) {
		/* for each new plot, line_type gets called twice with a value of -2.
		   It gets called once for the border and again for the tics.
		   This code will need to be changed if gnuplot's behavior changes.
		*/
		switch (ai_multiplot_group) {
			case 0:
				fprintf(outfile,"u\n");
				ai_subgroup_level++;
				ai_multiplot_group = 1;
				break;
			case 1:
				ai_multiplot_group = 2;
				break;
			case 2:
				ai_multiplot_group = 1;
				fprintf(outfile,"U\n");
				fprintf(outfile,"u\n");
				break;
			}
	}
	if (linetype == -2 && !multiplot) {
		if (ai_multiplot_group) {
			fprintf(outfile,"U\n");
			ai_subgroup_level--;
			ai_multiplot_group = 0;
		}	
	}
	fprintf(outfile,"u\n");
	ai_subgroup_level++;
	
	switch(linetype) {
		case -2 : fprintf(outfile,"%.2f w\n",AI_LW/AI_SC*2.0);
				if (ai_color) {
					fprintf(outfile,"0 0 0 1 K\n");
				}
				else {				
					fprintf(outfile,"[] 0 d\n");
				}
				break;
				
		case -1 : fprintf(outfile,"%.2f w\n",AI_LW/AI_SC/2.0);
				if (ai_color) {
					fprintf(outfile,"0 0 0 1 K\n");
				}
				else {				
					fprintf(outfile,"[1 2] 0 d\n");
				}
				break;
				
		case 0 :  fprintf(outfile,"%.2f w\n",AI_LW/AI_SC);
				if (ai_color) {
					fprintf(outfile,"1 0 1 0 K\n");
				}
				else {				
					fprintf(outfile,"[] 0 d\n");
				}
				break;
				
		case 1 :  fprintf(outfile,"%.2f w\n",AI_LW/AI_SC);
				if (ai_color) {
					fprintf(outfile,"1 1 0 0 K\n");
				}
				else {				
					fprintf(outfile,"[4 2] 0 d\n");
				}
				break;
				
		case 2 :  fprintf(outfile,"%.2f w\n",AI_LW/AI_SC);
				if (ai_color) {
					fprintf(outfile,"0 1 1 0 K\n");
				}
				else {				
					fprintf(outfile,"[2 3] 0 d\n");
				}
				break;
				
		case 3 :  fprintf(outfile,"%.2f w\n",AI_LW/AI_SC);
				if (ai_color) {
					fprintf(outfile,"0 1 0 0 K\n");
				}
				else {				
					fprintf(outfile,"[1 1.5] 0 d\n");
				}
				break;
				
		case 4 :  fprintf(outfile,"%f w\n",AI_LW/AI_SC);
				if (ai_color) {
					fprintf(outfile,"1 0 0 0 K\n");
				}
				else {				
					fprintf(outfile,"[5 2 1 2] 0 d\n");
				}
				break;
				
		case 5 : fprintf(outfile,"%.2f w\n",AI_LW/AI_SC);
				if (ai_color) {
					fprintf(outfile,"0 0 1 0 K\n");
				}
				else {				
					fprintf(outfile,"[4 3 1 3] 0 d\n");
				}
				break;
				
		case 6 : fprintf(outfile,"%.2f w\n",AI_LW/AI_SC);
				if (ai_color) {
					fprintf(outfile,"0 0 0 1 K\n");
				}
				else {				
					fprintf(outfile,"[2 2 2 4] 0 d\n");
				}
				break;
				
		case 7 : fprintf(outfile,"%.2f w\n",AI_LW/AI_SC);
				if (ai_color) {
					fprintf(outfile,"0 0.7 1 0 K\n");
				}
				else {				
					fprintf(outfile,"[2 2 2 2 2 4] 0 d\n");
				}
				break;
				
		case 8 : fprintf(outfile,"%.2f w\n",AI_LW/AI_SC);
				if (ai_color) {
					fprintf(outfile,"0.5 0.5 0.5 0 K\n");
				}
				else {				
					fprintf(outfile,"[2 2 2 2 2 2 2 4] 0 d\n");
				}
				break;
		}
				
	ai_path_count = 0;
}


TERM_PUBLIC void AI_move(x,y)
unsigned int x,y;
{
	if (ai_stroke) fprintf(outfile,"S\n");
	fprintf(outfile,"%.2f %.2f m\n", x/AI_SC, y/AI_SC);
	ai_path_count += 1;
	ai_stroke = TRUE;
}


TERM_PUBLIC void AI_vector(x,y)
unsigned int x,y;
{
	fprintf(outfile,"%.2f %.2f l\n", x/AI_SC, y/AI_SC);
	ai_path_count += 1;
	ai_stroke = TRUE;
	if (ai_path_count >= 400) {
		fprintf(outfile,"S\n%.2f %.2f m\n",x/AI_SC,y/AI_SC);
		ai_path_count = 0;
	}
}


TERM_PUBLIC void AI_put_text(x,y,str)
unsigned int x, y;
char *str;
{
char ch;
	if (ai_stroke) {
		fprintf(outfile,"S\n");
		ai_stroke = FALSE;
	}
	switch(ai_justify) {
		case LEFT :   fprintf(outfile,"/_%s %d 0 0 0 z\n",ai_font,ai_fontsize);
			break;
		case CENTRE : fprintf(outfile,"/_%s %d 0 0 1 z\n",ai_font,ai_fontsize);
			break;
		case RIGHT :  fprintf(outfile,"/_%s %d 0 0 2 z\n",ai_font,ai_fontsize);
			break;
	}
	if (ai_ang==0) {
		fprintf(outfile,"[ 1 0 0 1 %.2f %.2f] e\n",
			x/AI_SC,y/AI_SC - ai_fontsize/3.0);
	}
	else {
		fprintf(outfile,"[ 0 1 -1 0 %.2f %.2f] e\n",
			x/AI_SC - ai_fontsize/3.0,y/AI_SC);
	}
		
	putc('(',outfile);
	ch = *str++;
	while(ch!='\0') {
		if ( (ch=='(') || (ch==')') || (ch=='\\') )
			putc('\\',outfile);
		putc(ch,outfile);
		ch = *str++;
	}
	fprintf(outfile,") t\nT\n");
	ai_path_count = 0;
}

TERM_PUBLIC int AI_text_angle(ang)
int ang;
{
	ai_ang=ang;
	return TRUE;
}

TERM_PUBLIC int AI_justify_text(mode)
enum JUSTIFY mode;
{
	ai_justify=mode;
	return TRUE;
}

TERM_PUBLIC int AI_set_font(font)  /* Entry font added by DJL */
char *font;
{
char name[32];
int  size,sep;

	if (font && *font) {
		sep=strcspn(font,",");
 		strncpy(name,font,sep); name[sep]='\0';
 		size=ai_fontsize; sscanf (&(font[sep+1]),"%d",&size);
 		if (*name)
        	strcpy(ai_font, name);
      if (size)
      	ai_fontsize = size;
	} else {
		ai_fontsize = ai_oldfontsize;
		strcpy(ai_font, ai_oldfont);
	}
   return TRUE;
}


TERM_PUBLIC void AI_suspend()
{
}

TERM_PUBLIC void AI_resume()
{
}


#endif


#ifdef TERM_TABLE

TERM_TABLE_START(aifm_driver)

     	"aifm", "Adobe Illustrator 3.0 Format",
	   AI_XMAX, AI_YMAX, AI_VCHAR, AI_HCHAR, 
	   AI_VTIC, AI_HTIC, AI_options, AI_init, AI_reset, 
	   AI_text, null_scale, AI_graphics, AI_move, AI_vector, 
	   AI_linetype, AI_put_text, AI_text_angle, 
	   AI_justify_text, do_point, do_arrow, AI_set_font,
	   NULL, 0, AI_suspend, AI_resume}

#undef LAST_TERM
#define LAST_TERM aifm_driver
#endif
#endif /* TERM_PROTO_ONLY */


#ifdef TERM_HELP
START_HELP(aifm)
"1 aifm",
"?set terminal aifm",
"?set term aifm",
"?terminal aifm",
"?term aifm",
"?aifm",
" Several options may be set in `aifm`---the Adobe Illustrator 3.0+ driver.",
"",
" Syntax:",
"       set terminal aifm {<color>} {\"<fontname>\"} {<fontsize>}",
"",
" <color> is either `color` or `monochrome`; \"<fontname>\" is the name of a",
" valid PostScript font; <fontsize> is the size of the font in PostScript",
" points, before scaling by the `set size` command.  Selecting `default` sets",
" all options to their default values: `monochrome`, \"Helvetica\", and 14pt.",
"",
" Since AI does not really support multiple pages, multiple graphs will be",
" drawn directly on top of one another.  However, each graph will be grouped",
" individually, making it easy to separate them inside AI (just pick them up",
" and move them).",
"",
" Examples:",
"       set term aifm",
"       set term aifm 22",
"       set size 0.7,1.4; set term aifm color \"Times-Roman\" 14"
END_HELP(ai)
#endif
