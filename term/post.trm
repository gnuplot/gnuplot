/*
 * $Id: post.trm,v 1.102 2004/02/02 06:19:56 sfeam Exp $
 */

/* GNUPLOT - post.trm */

/*[
 * Copyright 1990 - 1993, 1998, 1999, 2000, 2001
 *
 * Permission to use, copy, and distribute this software and its
 * documentation for any purpose with or without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.
 *
 * Permission to modify the software is granted, but not the right to
 * distribute the complete modified source code.  Modifications are to
 * be distributed as patches to the released version.  Permission to
 * distribute binaries produced by compiling modified sources is granted,
 * provided you
 *   1. distribute the corresponding source modifications from the
 *    released version in the form of a patch file along with the binaries,
 *   2. add special version identification to distinguish your version
 *    in addition to the base release version number,
 *   3. provide your name and address as the primary contact for the
 *    support of your modified version, and
 *   4. retain our contact information in regard to use of the base
 *    software.
 * Permission to distribute the released version of the source code along
 * with corresponding source modifications in the form of a patch file is
 * granted with same provisions 2 through 4 for binary distributions.
 *
 * This software is provided "as is" without express or implied warranty
 * to the extent permitted by applicable law.
]*/

/*
 * This terminal driver supports:
 *     postscript
 *
 * AUTHORS
 *  Russell Lang  <rjl@monu1.cc.monash.edu.au>
 *
 * modified 10/5/95 by drd - put in support for other postscript drivers
 * (enhpost, pslatex, ...) so they dont have to work quite so hard
 * 
 * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
 *
 * The 'postscript' driver produces landscape output 10" wide and 7" high.  
 * To change font to Times-Roman and font size to 20pts use 
 * 'set term postscript "Times-Roman" 20'.
 * To get a smaller (5" x 3.5") eps output use 'set term post eps'
 * and make only one plot per file.  Font size for eps will be half
 * the specified size.
 *
 * Erik Luijten 30/5/97: added %%CreationDate, made %%DocumentFonts conform
 *                       to DSC, added version no. and patchl. to %%Creator
 * Petr Mikulik, Jan 1999: terminal entries for PM3D functionality
 *
 * Dick Crawford 24/5/00: added 'a{}{}' syntax to allow for overprinting
 *
 */

#include "driver.h"

#ifdef TERM_REGISTER
register_term(post)
#endif

#ifdef TERM_PROTO
TERM_PUBLIC void PS_options __PROTO((void));
TERM_PUBLIC void PS_common_init __PROTO((int encap, int portrait, int uses_fonts, unsigned int xoff, unsigned int yoff, unsigned int bb_xmin, unsigned int bb_ymin, unsigned int bb_xmax, unsigned int bb_ymax, const char **dict));
TERM_PUBLIC void PS_init __PROTO((void));
TERM_PUBLIC void PS_graphics __PROTO((void));
TERM_PUBLIC void PS_text __PROTO((void));
TERM_PUBLIC void PS_reset __PROTO((void));
TERM_PUBLIC void PS_linetype __PROTO((int linetype));
TERM_PUBLIC void PS_move __PROTO((unsigned int x, unsigned int y));
TERM_PUBLIC void PS_vector __PROTO((unsigned int x, unsigned int y));
TERM_PUBLIC void PS_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
TERM_PUBLIC int PS_text_angle __PROTO((int ang));
TERM_PUBLIC int PS_justify_text __PROTO((enum JUSTIFY mode));
TERM_PUBLIC void PS_point __PROTO((unsigned int x, unsigned int y, int number));
TERM_PUBLIC int PS_set_font __PROTO((const char * font));
TERM_PUBLIC void PS_fillbox __PROTO((int style, unsigned int x1, unsigned int y1, unsigned int width, unsigned int height));
TERM_PUBLIC void PS_linewidth __PROTO((double linewidth)); /* JFi [linewidth] */
TERM_PUBLIC void PS_pointsize __PROTO((double ptsize)); /* JFi [pointsize] */
#ifdef PM3D
TERM_PUBLIC int PS_make_palette (t_sm_palette *);
TERM_PUBLIC void PS_previous_palette (void);
TERM_PUBLIC void PS_set_color (double);
TERM_PUBLIC void PS_filled_polygon (int, gpiPoint *);
#endif /* PM3D */

/* To support "set term post enhanced" */
TERM_PUBLIC void ENHPS_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
TERM_PUBLIC int  ENHPS_set_font __PROTO((const char * font));
TERM_PUBLIC void ENHPS_OPEN __PROTO((char * fontname, double fontsize,
	    		double base, TBOOLEAN widthflag, TBOOLEAN showflag,
			int overprint));
TERM_PUBLIC void ENHPS_FLUSH __PROTO((void));
TERM_PUBLIC void ENHPS_WRITEC __PROTO((char c));
TERM_PUBLIC char *PS_RememberFont __PROTO((char *fname, int reencode));

#endif /* TERM_PROTO */

#ifndef TERM_PROTO_ONLY

#ifdef TERM_BODY

#include "post.h"
#ifdef PM3D
# include "getcolor.h"
# include <stdio.h>
#endif

#define PS_FLUSH_PATH do {			\
    if (ps_path_count) {			\
	fprintf(gpoutfile, "stroke\n");		\
	ps_path_count = 0;			\
	PS_relative_ok = FALSE;			\
    }						\
} while (0)

static void ENHPS_put_text __PROTO((unsigned int x, unsigned int y, const char *str));
static char ps_font[MAX_ID_LEN+1] = "Helvetica" ; /* name of font */
static int ps_fontsize = 14;					 /* size of font in pts */

#ifdef PM3D
static int ps_palfunc_samples = 2000;        /* setable via "palf$uncparam" */
static double ps_palfunc_deviation = 0.003;  /* terminal option */ 
static void make_interpolation_code __PROTO(());
static void make_color_model_code __PROTO(());
static char * save_space __PROTO(( double gray ));
static void write_component_array __PROTO(( const char *text, gradient_struct *grad, int cnt, int offset ));
static void write_gradient_definition __PROTO(( gradient_struct *gradient, int cnt ));
static void write_color_space __PROTO(( t_sm_palette *palette ));
static void make_palette_formulae __PROTO(());
#endif /* PM3D */

/* for enhanced mode, we keep a separate font name and size, which
 * is restored to the default value on font of ""
 */
static char ps_enh_font[MAX_ID_LEN+1];
static int  ps_enh_fontsize;

static TBOOLEAN ps_portrait = FALSE;				 /* vertical page */
static TBOOLEAN ps_color = FALSE;
static TBOOLEAN ps_blacktext = FALSE;           /*  text always black  */
static TBOOLEAN ps_solid = FALSE;   		/*  use solid lines */
static float ps_dash_length = 1.0;   /*  scale factor for dash-dot patterns  */
static float ps_linewidth_factor = 1.0;   /*  scale factor for linewidth  */
static TBOOLEAN ps_eps = FALSE;	/* Is this for an eps file? */
			/* Added by Robert Davis <davis@ecn.purdue.edu> */
static int ps_page = 0;		/* page count */
static int ps_path_count = 0; 	/* count of lines in path */
static int ps_ang = 0;			/* text angle */
static enum JUSTIFY ps_justify = LEFT;	/* text is flush left */

/* added by Matt Heffron <heffron@falstaff.css.beckman.com> */
static TBOOLEAN ps_duplex_state = FALSE;
static TBOOLEAN ps_duplex_option = FALSE;

/* added by Harald Harders <h.harders@tu-bs.de> */
static TBOOLEAN ps_rounded = FALSE;	/* rounded linecaps and linejoins */

/* Datastructure implementing inclusion of font files */
struct ps_fontfile_def {
    struct ps_fontfile_def *next;/* pointer to next fontfile in linked list */
    char *fontfile_name;
    char *fontfile_fullname;
};
struct ps_fontfile_def *first_ps_fontfile = NULL;
static void delete_ps_fontfile __PROTO((struct ps_fontfile_def *, struct ps_fontfile_def *));
TERM_PUBLIC void PS_load_fontfile __PROTO((struct ps_fontfile_def *,TBOOLEAN));
TERM_PUBLIC void PS_load_fontfiles __PROTO((TBOOLEAN));



static const char GPFAR * GPFAR PS_header[] = {
"/M {moveto} bind def\n",
"/L {lineto} bind def\n",
"/R {rmoveto} bind def\n",
"/V {rlineto} bind def\n",
"/N {newpath moveto} bind def\n",
"/C {setrgbcolor} bind def\n", 
"/f {rlineto fill} bind def\n",
"/vpt2 vpt 2 mul def\n",
"/hpt2 hpt 2 mul def\n",
/* flush left show */
"/Lshow { currentpoint stroke M\n",
"  0 vshift R show } def\n", 
/* flush right show */
"/Rshow { currentpoint stroke M\n",
"  dup stringwidth pop neg vshift R show } def\n", 
/* centred show */
"/Cshow { currentpoint stroke M\n",
"  dup stringwidth pop -2 div vshift R show } def\n", 
/* set pointsize */
"/UP { dup vpt_ mul /vpt exch def hpt_ mul /hpt exch def\n",
"  /hpt2 hpt 2 mul def /vpt2 vpt 2 mul def } def\n",
/* Dash or Color Line */
"/DL { Color {setrgbcolor Solid {pop []} if 0 setdash }\n",
" {pop pop pop 0 setgray Solid {pop []} if 0 setdash} ifelse } def\n",
/* Border Lines */
"/BL { stroke userlinewidth 2 mul setlinewidth\n",
"      Rounded { 1 setlinejoin 1 setlinecap } if } def\n",
/* Axes Lines */
"/AL { stroke userlinewidth 2 div setlinewidth\n",
"      Rounded { 1 setlinejoin 1 setlinecap } if } def\n",
/* set user defined linewidth */
"/UL { dup gnulinewidth mul /userlinewidth exch def\n",
"      dup 1 lt {pop 1} if 10 mul /udl exch def } def\n",
/* Plot Lines */
"/PL { stroke userlinewidth setlinewidth\n",
"      Rounded { 1 setlinejoin 1 setlinecap } if } def\n",
/* Line Types */
"/LTw { PL [] 1 setgray } def\n", /* background (assumed white) */
"/LTb { BL [] 0 0 0 DL } def\n", /* border */
"/LTa { AL [1 udl mul 2 udl mul] 0 setdash 0 0 0 setrgbcolor } def\n", /* axes */
"/LT0 { PL [] 1 0 0 DL } def\n",
"/LT1 { PL [4 dl 2 dl] 0 1 0 DL } def\n",
"/LT2 { PL [2 dl 3 dl] 0 0 1 DL } def\n",
"/LT3 { PL [1 dl 1.5 dl] 1 0 1 DL } def\n",
"/LT4 { PL [5 dl 2 dl 1 dl 2 dl] 0 1 1 DL } def\n",
"/LT5 { PL [4 dl 3 dl 1 dl 3 dl] 1 1 0 DL } def\n",
"/LT6 { PL [2 dl 2 dl 2 dl 4 dl] 0 0 0 DL } def\n",
"/LT7 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 1 0.3 0 DL } def\n",
"/LT8 { PL [2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 2 dl 4 dl] 0.5 0.5 0.5 DL } def\n",
/* Point (Round) */	/* Matt Heffron make it round */
"/Pnt { stroke [] 0 setdash\n",
"   gsave 1 setlinecap M 0 0 V stroke grestore } def\n",

/* Diamond */
"/Dia { stroke [] 0 setdash 2 copy vpt add M\n",
"  hpt neg vpt neg V hpt vpt neg V\n",
"  hpt vpt V hpt neg vpt V closepath stroke\n",
"  Pnt } def\n",

/* Plus */
"/Pls { stroke [] 0 setdash vpt sub M 0 vpt2 V\n",
"  currentpoint stroke M\n",
"  hpt neg vpt neg R hpt2 0 V stroke\n",
"  } def\n",

/* Box */
"/Box { stroke [] 0 setdash 2 copy exch hpt sub exch vpt add M\n",
"  0 vpt2 neg V hpt2 0 V 0 vpt2 V\n",
"  hpt2 neg 0 V closepath stroke\n",
"  Pnt } def\n",

/* Cross (X) */
"/Crs { stroke [] 0 setdash exch hpt sub exch vpt add M\n",
"  hpt2 vpt2 neg V currentpoint stroke M\n",
"  hpt2 neg 0 R hpt2 vpt2 V stroke } def\n",

/* Triangle Up*/
"/TriU { stroke [] 0 setdash 2 copy vpt 1.12 mul add M\n",
"  hpt neg vpt -1.62 mul V\n",
"  hpt 2 mul 0 V\n",
"  hpt neg vpt 1.62 mul V closepath stroke\n",
"  Pnt  } def\n",

/* Star */
"/Star { 2 copy Pls Crs } def\n",

/* div added filed box */
/* Filled Box */
"/BoxF { stroke [] 0 setdash exch hpt sub exch vpt add M\n",
"  0 vpt2 neg V  hpt2 0 V  0 vpt2 V\n",
"  hpt2 neg 0 V  closepath fill } def\n",

/* div added filled triangle */
/* Triangle Up, Filled */
"/TriUF { stroke [] 0 setdash vpt 1.12 mul add M\n",
"  hpt neg vpt -1.62 mul V\n",
"  hpt 2 mul 0 V\n",
"  hpt neg vpt 1.62 mul V closepath fill } def\n",

/* Matt Heffron: added a few more types */
/* Triangle Down */
"/TriD { stroke [] 0 setdash 2 copy vpt 1.12 mul sub M\n", 
"  hpt neg vpt 1.62 mul V\n",
"  hpt 2 mul 0 V\n",
"  hpt neg vpt -1.62 mul V closepath stroke\n",
"  Pnt  } def\n",

/* Triangle Down, Filled*/
"/TriDF { stroke [] 0 setdash vpt 1.12 mul sub M\n",
"  hpt neg vpt 1.62 mul V\n",
"  hpt 2 mul 0 V\n",
"  hpt neg vpt -1.62 mul V closepath fill} def\n",

/* Diamond, Filled */
"/DiaF { stroke [] 0 setdash vpt add M\n",
"  hpt neg vpt neg V hpt vpt neg V\n",
"  hpt vpt V hpt neg vpt V closepath fill } def\n",

/* Pentagon */
"/Pent { stroke [] 0 setdash 2 copy gsave\n",
"  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat\n",
"  closepath stroke grestore Pnt } def\n",

/* Pentagon, Filled */
"/PentF { stroke [] 0 setdash gsave\n",
"  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat\n",
"  closepath fill grestore } def\n",

/* Circle */
"/Circle { stroke [] 0 setdash 2 copy\n",
"  hpt 0 360 arc stroke Pnt } def\n",

/* Circle,Filled */
"/CircleF { stroke [] 0 setdash hpt 0 360 arc fill } def\n",
/* 16 differently filled circles */
"/C0 { BL [] 0 setdash 2 copy moveto vpt 90 450  arc } bind def\n",
"/C1 { BL [] 0 setdash 2 copy        moveto\n",
"       2 copy  vpt 0 90 arc closepath fill\n",
"               vpt 0 360 arc closepath } bind def\n",
"/C2 { BL [] 0 setdash 2 copy moveto\n",
"       2 copy  vpt 90 180 arc closepath fill\n",
"               vpt 0 360 arc closepath } bind def\n",
"/C3 { BL [] 0 setdash 2 copy moveto\n",
"       2 copy  vpt 0 180 arc closepath fill\n",
"               vpt 0 360 arc closepath } bind def\n",
"/C4 { BL [] 0 setdash 2 copy moveto\n",
"       2 copy  vpt 180 270 arc closepath fill\n",
"               vpt 0 360 arc closepath } bind def\n",
"/C5 { BL [] 0 setdash 2 copy moveto\n",
"       2 copy  vpt 0 90 arc\n",
"       2 copy moveto\n",
"       2 copy  vpt 180 270 arc closepath fill\n",
"               vpt 0 360 arc } bind def\n",
"/C6 { BL [] 0 setdash 2 copy moveto\n",
"      2 copy  vpt 90 270 arc closepath fill\n",
"              vpt 0 360 arc closepath } bind def\n",
"/C7 { BL [] 0 setdash 2 copy moveto\n",
"      2 copy  vpt 0 270 arc closepath fill\n",
"              vpt 0 360 arc closepath } bind def\n",
"/C8 { BL [] 0 setdash 2 copy moveto\n",
"      2 copy vpt 270 360 arc closepath fill\n",
"              vpt 0 360 arc closepath } bind def\n",
"/C9 { BL [] 0 setdash 2 copy moveto\n",
"      2 copy  vpt 270 450 arc closepath fill\n",
"              vpt 0 360 arc closepath } bind def\n",
"/C10 { BL [] 0 setdash 2 copy 2 copy moveto vpt 270 360 arc closepath fill\n",
"       2 copy moveto\n",
"       2 copy vpt 90 180 arc closepath fill\n",
"               vpt 0 360 arc closepath } bind def\n",
"/C11 { BL [] 0 setdash 2 copy moveto\n",
"       2 copy  vpt 0 180 arc closepath fill\n",
"       2 copy moveto\n",
"       2 copy  vpt 270 360 arc closepath fill\n",
"               vpt 0 360 arc closepath } bind def\n",
"/C12 { BL [] 0 setdash 2 copy moveto\n",
"       2 copy  vpt 180 360 arc closepath fill\n",
"               vpt 0 360 arc closepath } bind def\n",
"/C13 { BL [] 0 setdash  2 copy moveto\n",
"       2 copy  vpt 0 90 arc closepath fill\n",
"       2 copy moveto\n",
"       2 copy  vpt 180 360 arc closepath fill\n",
"               vpt 0 360 arc closepath } bind def\n",
"/C14 { BL [] 0 setdash 2 copy moveto\n",
"       2 copy  vpt 90 360 arc closepath fill\n",
"               vpt 0 360 arc } bind def\n",
"/C15 { BL [] 0 setdash 2 copy vpt 0 360 arc closepath fill\n",
"               vpt 0 360 arc closepath } bind def\n",

/* Auxiliary definitions for rectangles */

"/Rec   { newpath 4 2 roll moveto 1 index 0 rlineto 0 exch rlineto\n",
"       neg 0 rlineto closepath } bind def\n",
"/Square { dup Rec } bind def\n",
"/Bsquare { vpt sub exch vpt sub exch vpt2 Square } bind def\n",

/* 16 differently filled squares */

"/S0 { BL [] 0 setdash 2 copy moveto 0 vpt rlineto BL Bsquare } bind def\n",
"/S1 { BL [] 0 setdash 2 copy vpt Square fill Bsquare } bind def\n",
"/S2 { BL [] 0 setdash 2 copy exch vpt sub exch vpt Square fill Bsquare } bind def\n",
"/S3 { BL [] 0 setdash 2 copy exch vpt sub exch vpt2 vpt Rec fill Bsquare } bind def\n",
"/S4 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def\n",
"/S5 { BL [] 0 setdash 2 copy 2 copy vpt Square fill\n",
"       exch vpt sub exch vpt sub vpt Square fill Bsquare } bind def\n",
"/S6 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill Bsquare } bind def\n",
"/S7 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt vpt2 Rec fill\n",
"       2 copy vpt Square fill\n",
"       Bsquare } bind def\n",
"/S8 { BL [] 0 setdash 2 copy vpt sub vpt Square fill Bsquare } bind def\n",
"/S9 { BL [] 0 setdash 2 copy vpt sub vpt vpt2 Rec fill Bsquare } bind def\n",
"/S10 { BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt Square fill\n",
"       Bsquare } bind def\n",
"/S11 { BL [] 0 setdash 2 copy vpt sub vpt Square fill 2 copy exch vpt sub exch vpt2 vpt Rec fill\n",
"       Bsquare } bind def\n",
"/S12 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill Bsquare } bind def\n",
"/S13 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill\n",
"       2 copy vpt Square fill Bsquare } bind def\n",
"/S14 { BL [] 0 setdash 2 copy exch vpt sub exch vpt sub vpt2 vpt Rec fill\n",
"       2 copy exch vpt sub exch vpt Square fill Bsquare } bind def\n",
"/S15 { BL [] 0 setdash 2 copy Bsquare fill Bsquare } bind def\n",

/* 16 different diamonds (actually just rotated squares) */

"/D0 { gsave translate 45 rotate 0 0 S0 stroke grestore } bind def\n",
"/D1 { gsave translate 45 rotate 0 0 S1 stroke grestore } bind def\n",
"/D2 { gsave translate 45 rotate 0 0 S2 stroke grestore } bind def\n",
"/D3 { gsave translate 45 rotate 0 0 S3 stroke grestore } bind def\n",
"/D4 { gsave translate 45 rotate 0 0 S4 stroke grestore } bind def\n",
"/D5 { gsave translate 45 rotate 0 0 S5 stroke grestore } bind def\n",
"/D6 { gsave translate 45 rotate 0 0 S6 stroke grestore } bind def\n",
"/D7 { gsave translate 45 rotate 0 0 S7 stroke grestore } bind def\n",
"/D8 { gsave translate 45 rotate 0 0 S8 stroke grestore } bind def\n",
"/D9 { gsave translate 45 rotate 0 0 S9 stroke grestore } bind def\n",
"/D10 { gsave translate 45 rotate 0 0 S10 stroke grestore } bind def\n",
"/D11 { gsave translate 45 rotate 0 0 S11 stroke grestore } bind def\n",
"/D12 { gsave translate 45 rotate 0 0 S12 stroke grestore } bind def\n",
"/D13 { gsave translate 45 rotate 0 0 S13 stroke grestore } bind def\n",
"/D14 { gsave translate 45 rotate 0 0 S14 stroke grestore } bind def\n",
"/D15 { gsave translate 45 rotate 0 0 S15 stroke grestore } bind def\n",

/* closed figures w/o the point in the middle (added by Dick Crawford) */

/* Diamond */
"/DiaE { stroke [] 0 setdash vpt add M\n",
"  hpt neg vpt neg V hpt vpt neg V\n",
"  hpt vpt V hpt neg vpt V closepath stroke } def\n",

/* Box */
"/BoxE { stroke [] 0 setdash exch hpt sub exch vpt add M\n",
"  0 vpt2 neg V hpt2 0 V 0 vpt2 V\n",
"  hpt2 neg 0 V closepath stroke } def\n",

/* Triangle Up*/
"/TriUE { stroke [] 0 setdash vpt 1.12 mul add M\n",
"  hpt neg vpt -1.62 mul V\n",
"  hpt 2 mul 0 V\n",
"  hpt neg vpt 1.62 mul V closepath stroke } def\n",

/* Triangle Down */
"/TriDE { stroke [] 0 setdash vpt 1.12 mul sub M\n", 
"  hpt neg vpt 1.62 mul V\n",
"  hpt 2 mul 0 V\n",
"  hpt neg vpt -1.62 mul V closepath stroke } def\n",

/* Pentagon */
"/PentE { stroke [] 0 setdash gsave\n",
"  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat\n",
"  closepath stroke grestore } def\n",

/* Circle */
"/CircE { stroke [] 0 setdash \n",
"  hpt 0 360 arc stroke } def\n",

/* opaque closed figures w/o the point in the middle (added by Dick Crawford) */

"/Opaque { gsave closepath 1 setgray fill grestore 0 setgray closepath } def\n",

/* Diamond */
"/DiaW { stroke [] 0 setdash vpt add M\n",
"  hpt neg vpt neg V hpt vpt neg V\n",
"  hpt vpt V hpt neg vpt V Opaque stroke } def\n",

/* Box */
"/BoxW { stroke [] 0 setdash exch hpt sub exch vpt add M\n",
"  0 vpt2 neg V hpt2 0 V 0 vpt2 V\n",
"  hpt2 neg 0 V Opaque stroke } def\n",

/* Triangle Up*/
"/TriUW { stroke [] 0 setdash vpt 1.12 mul add M\n",
"  hpt neg vpt -1.62 mul V\n",
"  hpt 2 mul 0 V\n",
"  hpt neg vpt 1.62 mul V Opaque stroke } def\n",

/* Triangle Down */
"/TriDW { stroke [] 0 setdash vpt 1.12 mul sub M\n", 
"  hpt neg vpt 1.62 mul V\n",
"  hpt 2 mul 0 V\n",
"  hpt neg vpt -1.62 mul V Opaque stroke } def\n",

/* Pentagon */
"/PentW { stroke [] 0 setdash gsave\n",
"  translate 0 hpt M 4 {72 rotate 0 hpt L} repeat\n",
"  Opaque stroke grestore } def\n",

/* Circle */
"/CircW { stroke [] 0 setdash \n",
"  hpt 0 360 arc Opaque stroke } def\n",

/* filled box : usage   x1 y1 x2 y2 BoxFill */
"/BoxFill { gsave Rec 1 setgray fill grestore } def\n",

#if USE_ULIG_FILLEDBOXES
/* filled box in current color,
   but color lightened up as defined by filldensity (ULIG),
   usage:   x1 y1 x2 y2 BoxColFill */
"/BoxColFill {\n",
"  gsave Rec\n",
"  /Fillden exch def\n",
"  currentrgbcolor\n",
"  /ColB exch def /ColG exch def /ColR exch def\n",
"  /ColR ColR Fillden mul Fillden sub 1 add def\n",
"  /ColG ColG Fillden mul Fillden sub 1 add def\n",
"  /ColB ColB Fillden mul Fillden sub 1 add def\n",
"  ColR ColG ColB setrgbcolor\n",
"  fill grestore } def\n",

"%\n",
"% PostScript Level 1 Pattern Fill routine\n",
/* original code: Dick Crawford <crawford@arete.com> */
/* modified by: Ethan A Merritt <merritt@u.washington.edu> */
"% Usage: x y w h s a XX PatternFill\n",
"%	x,y = lower left corner of box to be filled\n",
"%	w,h = width and height of box\n",
"%	  a = angle in degrees between lines and x-axis\n",
"%	 XX = 0/1 for no/yes cross-hatch\n",
"%\n",
"/PatternFill { gsave /PFa [ 9 2 roll ] def\n",
"    PFa 0 get PFa 2 get 2 div add PFa 1 get PFa 3 get 2 div add translate\n",
"    PFa 2 get -2 div PFa 3 get -2 div PFa 2 get PFa 3 get Rec\n",
"    gsave 1 setgray fill grestore clip\n",
"    currentlinewidth 0.5 mul setlinewidth\n",
"    /PFs PFa 2 get dup mul PFa 3 get dup mul add sqrt def\n",
"    0 0 M PFa 5 get rotate PFs -2 div dup translate\n",
"	0 1 PFs PFa 4 get div 1 add floor cvi\n",
"	{ PFa 4 get mul 0 M 0 PFs V } for\n",
"    0 PFa 6 get ne {\n",
"	0 1 PFs PFa 4 get div 1 add floor cvi\n",
"	{ PFa 4 get mul 0 2 1 roll M PFs 0 V } for\n",
"    } if\n",
"    stroke grestore } def\n",
"%\n",

#endif /* USE_ULIG_FILLEDBOXES */

/* oblique symbol font, e.g. set xlabel 'b' "Symbol-Oblique"
   gives an oblique (slanted) beta character */
"/Symbol-Oblique /Symbol findfont [1 0 .167 1 0 0] makefont\n",
"dup length dict begin {1 index /FID eq {pop pop} {def} ifelse} forall\n",
"currentdict end definefont pop\n",

NULL
};

static const char GPFAR * GPFAR ENHPS_header[] = {
/* For MFshow and MFwidth the tos is an array with the string and font info:  */
/*	[<fontname (a string)> <fontsize> <vertical offset> <width significant?> <printed?> <overprint> <text string>]  */

"/MFshow {{dup dup 0 get findfont exch 1 get scalefont setfont\n",
"     [ currentpoint ] exch dup 2 get 0 exch R dup 5 get 2 ne {dup dup 6\n",
"     get exch 4 get {show} {stringwidth pop 0 R} ifelse }if dup 5 get 0 eq\n",
"     {dup 3 get {2 get neg 0 exch R pop} {pop aload pop M} ifelse} {dup 5\n",
"     get 1 eq {dup 2 get exch dup 3 get exch 6 get stringwidth pop -2 div\n",
"     dup 0 R} {dup 6 get stringwidth pop -2 div 0 R 6 get\n",
"     show 2 index {aload pop M neg 3 -1 roll neg R pop pop} {pop pop pop\n",
"     pop aload pop M} ifelse }ifelse }ifelse } forall} bind def\n",
"/MFwidth {0 exch {dup 3 get{dup dup 0 get findfont exch 1 get scalefont\n",
"     setfont 6 get stringwidth pop add} {pop} ifelse} forall} bind def\n",

/* flush left show */
"/MLshow { currentpoint stroke M\n",
"  0 exch R MFshow } bind def\n", 

/* flush right show */
"/MRshow { currentpoint stroke M\n",
"  exch dup MFwidth neg 3 -1 roll R MFshow } def\n", 

/* centred show */
"/MCshow { currentpoint stroke M\n",
"  exch dup MFwidth -2 div 3 -1 roll R MFshow } def\n", 
NULL
};

/* added to enhpost by Matt Heffron <heffron@falstaff.css.beckman.com> */
/* moved to post.trm by drd */

static struct PS_FontName {
	char *name;
	struct PS_FontName *next;
} *PS_DocFonts = NULL;

static char PS_default_font[MAX_ID_LEN+1] = {'\0'};

/* given a font, look in store to see if it is there already
 * if so, return NULL. If not, reencode it if allowed to, otherwise
 * return an appropriate re-encode string
 */
 
TERM_PUBLIC char *
PS_RememberFont(fname, can_reencode)
char *fname;
int can_reencode;
{
    struct PS_FontName *fnp;
    char *recode = NULL;
    char *myfname = "Symbol";

    if (strcmp(fname, "Symbol-Oblique") != 0)
	myfname = fname;

    for (fnp = PS_DocFonts; fnp ; fnp = fnp->next)
	if (strcmp(fnp->name, myfname) == 0)
	    return NULL;

    /* we did not find the name */
   
    fnp = (struct PS_FontName *)gp_alloc(sizeof(struct PS_FontName),
					 "PostScript Font record");
    fnp->name = gp_strdup(myfname);
    fnp->next = PS_DocFonts;
    PS_DocFonts = fnp;

    switch(encoding) {
    case S_ENC_ISO8859_1:
	recode = "reencodeISO def\n";
	break;
    case S_ENC_ISO8859_2:
	recode = "reencodeISO2 def\n";
	break;
    case S_ENC_ISO8859_15:
	recode = "reencodeISO15 def\n";
	break;
    case S_ENC_CP437:
	recode = "reencodeCP437 def\n";
	break;
    case S_ENC_CP850 : 
	recode = "reencodeCP850 def\n";
	break;
    case S_ENC_CP852 :
	recode = "reencodeCP852 def\n";
	break;
    case S_ENC_KOI8_R :
	recode = "reencodeKOI8R def\n";
	break;
    default:
	/* do nothing */
	break;
    }

    if (can_reencode && recode) {
	fprintf(gpoutfile,"/%s %s", myfname, recode);
	return NULL;
    } else
	return recode;
}

static int PS_pen_x, PS_pen_y;
static int PS_taken;
static int PS_linetype_last;
static TBOOLEAN PS_relative_ok;

/* HBB 990914: PS_SOLID is already used by the WIN32 API headers.
 * Renamed to PS_SOLIDE, therefore... */
enum PS_id {
    PS_PORTRAIT, PS_LANDSCAPE,
    PS_EPSF, PS_DEFAULT, PS_ENHANCED, PS_NOENHANCED,
    PS_MONOCHROME, PS_COLOR, PS_BLACKTEXT, PS_COLORTEXT,
    PS_SOLIDE, PS_DASHED, PS_DASHLENGTH, PS_LINEWIDTH,
    PS_SIMPLEX, PS_DUPLEX, PS_DEFAULTPLEX,
    PS_ROUNDED, PS_NOROUNDED, PS_FONTFILE, PS_NOFONTFILES,
#ifdef PM3D
    PS_PALFUNCPARAM,
#endif /* PM3D */
    PS_OTHER
};

static struct gen_table PS_opts[] =
{
    { "p$ortrait", PS_PORTRAIT },
    { "l$andscape", PS_LANDSCAPE },
    { "ep$sf", PS_EPSF },
    { "enh$anced", PS_ENHANCED },
    { "noenh$anced", PS_NOENHANCED },
    { "m$onochrome", PS_MONOCHROME },
    { "c$olor", PS_COLOR },
    { "c$olour", PS_COLOR },
    { "b$lacktext", PS_BLACKTEXT },
    { "color$text", PS_COLORTEXT },
    { "colour$text", PS_COLORTEXT },
    { "so$lid", PS_SOLIDE },
    { "da$shed", PS_DASHED },
    { "dashl$ength", PS_DASHLENGTH },
    { "dl", PS_DASHLENGTH },
    { "linew$idth", PS_LINEWIDTH },
    { "lw", PS_LINEWIDTH },
    { "si$mplex", PS_SIMPLEX },
    { "du$plex", PS_DUPLEX },
    { "defaultp$lex", PS_DEFAULTPLEX },
    { "butt", PS_NOROUNDED },
    { "rou$nded", PS_ROUNDED },
    { "fontf$ile", PS_FONTFILE },
    { "nofontf$iles", PS_NOFONTFILES },
#ifdef PM3D
    { "palf$uncparam", PS_PALFUNCPARAM },
#endif /* PM3D */
    { NULL, PS_OTHER }
};


TERM_PUBLIC void
PS_options()
{
    struct value a;
    char *ps_fontfile_char = NULL;

    while (!END_OF_COMMAND) {
	switch(lookup_table(&PS_opts[0],c_token)) {
	case PS_PORTRAIT:
	    ps_portrait = TRUE;
	    ps_eps = FALSE;
	    c_token++;
	    break;
	case PS_LANDSCAPE:
	    ps_portrait = FALSE;
	    ps_eps = FALSE;
	    c_token++;
	    break;
	case PS_EPSF:
	    ps_portrait = TRUE;
	    ps_eps = TRUE;
	    c_token++;
	    break;
	case PS_DEFAULT:
	    ps_portrait = FALSE;
	    ps_eps = FALSE;
	    ps_color = FALSE;
	    ps_blacktext = FALSE;
	    ps_solid = FALSE;
	    ps_dash_length = 1.0;
	    ps_linewidth_factor = 1.0;
	    ps_duplex_option = FALSE;
	    ps_rounded = FALSE;
	    while (first_ps_fontfile != NULL) {
		delete_ps_fontfile((struct ps_fontfile_def *) NULL, 
				   first_ps_fontfile);
		first_ps_fontfile = NULL;
	    }
	    strcpy(ps_font,"Helvetica");
	    ps_fontsize = 14;
	    term->v_char = (unsigned int)(ps_fontsize*PS_SC);
	    term->h_char = (unsigned int)(ps_fontsize*PS_SC*6/10);
	    term->put_text = PS_put_text;
#ifdef PM3D
	    ps_palfunc_samples = 2000;
	    ps_palfunc_deviation = 0.003;
#endif /* PM3D */
	    c_token++;
	    break;
	case PS_ENHANCED:
	    term->put_text = ENHPS_put_text;
	    term->set_font = ENHPS_set_font;
	    ++c_token;
	    break;
	case PS_NOENHANCED:
	    term->put_text = PS_put_text;
	    term->set_font = PS_set_font;
	    ++c_token;
	    break;
	case PS_MONOCHROME:
	    ps_color = FALSE;
	    c_token++;
	    break;
	case PS_COLOR:
	    ps_color = TRUE;
	    c_token++;
	    break;
	case PS_BLACKTEXT:
	    ps_blacktext = TRUE;
	    c_token++;
	    break;
	case PS_COLORTEXT:
	    ps_blacktext = FALSE;
	    c_token++;
	    break;
        case PS_SOLIDE:
	    ps_solid = TRUE;
	    c_token++;
	    break;
	case PS_DASHED:
	    ps_solid = FALSE;
	    c_token++;
	    break;
	case PS_DASHLENGTH:
	    c_token++;
	    ps_dash_length = real(const_express(&a));
	    if (ps_dash_length <= 0.0)
		ps_dash_length = 1.0;
	    break;
	case PS_LINEWIDTH:
	    c_token++;
	    ps_linewidth_factor = real(const_express(&a));
	    if (ps_linewidth_factor <= 0.0)
		ps_linewidth_factor = 1.0;
	    break;
	case PS_SIMPLEX:
	    ps_duplex_state  = FALSE;
	    ps_duplex_option = TRUE;
	    c_token++;
	    break;
	case PS_DUPLEX:
	    ps_duplex_state  = TRUE;
	    ps_duplex_option = TRUE;
	    c_token++;
	    break;
	case PS_DEFAULTPLEX:
	    ps_duplex_option = FALSE;
	    c_token++;
	    break;
	case PS_ROUNDED:
	    ps_rounded = TRUE;
	    c_token++;
	    break;
	case PS_NOROUNDED:
	    ps_rounded = FALSE;
	    c_token++;
	    break;
        case PS_FONTFILE: {
            TBOOLEAN deleteentry = FALSE;
            c_token++;
           
            if (!isstring(c_token)) {
                if (equals(c_token, "add"))
                    c_token++;
                else if (almost_equals(c_token, "del$ete")) {
                    deleteentry = TRUE;
                    c_token++;
                } else
                    int_error(c_token, "Font filename expected");
            }
            if (isstring(c_token)) {
                TBOOLEAN filename_doubled = FALSE;
                struct ps_fontfile_def *curr_ps_fontfile = first_ps_fontfile;
                struct ps_fontfile_def *prev_ps_fontfile = NULL;
                struct ps_fontfile_def *new_ps_fontfile = 
                     gp_alloc(sizeof(struct ps_fontfile_def), 
                             "new_ps_fontfile");
 
                new_ps_fontfile->fontfile_name = 
                    gp_alloc (token_len(c_token), 
                              "new_ps_fontfile->fontfile_name");
                quote_str(new_ps_fontfile->fontfile_name, 
                          c_token, token_len(c_token));
                gp_expand_tilde(&(new_ps_fontfile->fontfile_name));
		if (!deleteentry) {
#if defined(PIPES)
		    if ( *(new_ps_fontfile->fontfile_name) != '<' ) {
#endif
			new_ps_fontfile->fontfile_fullname = 
			    fontpath_fullname(new_ps_fontfile->fontfile_name);
			if (!new_ps_fontfile->fontfile_fullname)
			    int_error(c_token, "Font file '%s' not found",
				      new_ps_fontfile->fontfile_name);
#if defined(PIPES)
		    } else
			new_ps_fontfile->fontfile_fullname = NULL;
#endif

		}
                new_ps_fontfile->next = NULL;

		if (!deleteentry) {
		    LFS *lf=lf_head;
		    if (lf) {
			while (lf->prev)
			    lf=lf->prev;
		    }
		    if ( (lf && lf->interactive) || interactive)
			/* if (interactive) { */
			PS_load_fontfile(new_ps_fontfile,FALSE);
		}

                if (first_ps_fontfile) {
                    while (curr_ps_fontfile) {
                        if (strcmp(curr_ps_fontfile->fontfile_name,
                                   new_ps_fontfile->fontfile_name) == 0) {
                            filename_doubled = TRUE;
                            if (deleteentry) {
				delete_ps_fontfile(prev_ps_fontfile, 
						   curr_ps_fontfile);
                                curr_ps_fontfile = NULL;
                                break;
                            }
                        }
                        prev_ps_fontfile = curr_ps_fontfile;
                        curr_ps_fontfile = curr_ps_fontfile->next;
                    }
                    if (!filename_doubled) {
                        if (!deleteentry)
                            prev_ps_fontfile->next = new_ps_fontfile;
                        else
                            int_warn(c_token,"Can't delete Font filename '%s'",
                                     new_ps_fontfile->fontfile_name);
                    }
                } else {
                    if (!deleteentry)
                        first_ps_fontfile = new_ps_fontfile;
                    else
                        int_warn(c_token, "Can't delete Font filename '%s'",
                                 new_ps_fontfile->fontfile_name);
                }
                c_token++;
            } else
                int_error(c_token, "Font filename expected");
            break;
        }
        case PS_NOFONTFILES:
	    while (first_ps_fontfile != NULL) {
		delete_ps_fontfile((struct ps_fontfile_def *) NULL, 
				   first_ps_fontfile);
		first_ps_fontfile = NULL;
	    }
	    ++c_token;
	    break;
#ifdef PM3D
	case PS_PALFUNCPARAM:
	    ++c_token;
	    ps_palfunc_samples = (int)real(const_express(&a));
	    if (ps_palfunc_samples < 2) ps_palfunc_samples = 2;
	    if ( !END_OF_COMMAND && equals(c_token, ",") ) {
	        ++c_token;
		ps_palfunc_deviation = fabs(real(const_express(&a)));
		if (ps_palfunc_deviation >= 1)
		    int_error(c_token-1,"allowed deviation must be < 1");
	    }
	    ++c_token;
	    break;
#endif /* PM3D */
	case PS_OTHER:
	default:
	    if (isstring(c_token)) {
		quote_str(ps_font,c_token, MAX_ID_LEN);
		c_token++;
	    } else {
		/* We have font size specified */
		ps_fontsize = (int)real(const_express(&a));
		term->v_char = (unsigned int)(ps_fontsize*PS_SC);
		term->h_char = (unsigned int)(ps_fontsize*PS_SC*6/10);
	    }
	    break;
	}
    }

    if (!ps_color)
	ps_blacktext = TRUE;

    sprintf(PS_default_font,"%s,%d",ps_font,ps_fontsize);
  
    if (first_ps_fontfile) {
	struct ps_fontfile_def *curr_ps_fontfile = first_ps_fontfile;
	unsigned int totlength = 0;
	char *running;

	while (curr_ps_fontfile) {
	    totlength += strlen(curr_ps_fontfile->fontfile_name) + 
		strlen(" fontfile \"\"");
	    curr_ps_fontfile = curr_ps_fontfile->next;
	}
	curr_ps_fontfile = first_ps_fontfile;
	ps_fontfile_char = gp_alloc (totlength+1,"ps_fontfile_char");
	running = ps_fontfile_char;
	while (curr_ps_fontfile) {
	    sprintf(running," fontfile \"%s\"",
		    curr_ps_fontfile->fontfile_name);
	    running += strlen(running);
	    curr_ps_fontfile = curr_ps_fontfile->next;
	}
    }
  
    /* HBB 19990823: fixed the options string. It violated the 'save
     * loadable output' rule */
    sprintf(term_options,"%s %senhanced %s %s \\\n"
	                 "   %s dashlength %.1f linewidth %.1f %s \\\n"
#ifdef PM3D
	                 "   palfuncparam %d,%g \\\n"
#endif /* PM3D */
	                 "   %s \"%s\" %d%s",
	    ps_eps ? "eps" : (ps_portrait ? "portrait" : "landscape"),
	    term->put_text == ENHPS_put_text ? "" : "no",
	    ps_color ? "color" : "monochrome",
	    ps_blacktext ? "blacktext" : "colortext",
	    ps_solid ? "solid" : "dashed",
	    ps_dash_length,
	    ps_linewidth_factor,
	    ps_duplex_option ? (ps_duplex_state ? "duplex" : "simplex")
	    : "defaultplex",
#ifdef PM3D
	    ps_palfunc_samples, ps_palfunc_deviation,
#endif /* PM3D */
	    ps_rounded ? "rounded" : "butt",
	    ps_font,ps_fontsize,
	    ps_fontfile_char ? ps_fontfile_char : "");
}

/* store settings passed to common_init() for use in PS_graphics()
 * ps_eps, ps_portrait, etc are reserved for storing the term options
 */
static int ps_common_encap;
static int ps_common_portrait;
static int ps_common_uses_fonts;
static unsigned int ps_common_xoff, ps_common_yoff;


TERM_PUBLIC void
PS_load_fontfile(current_ps_fontfile,doload)
     struct ps_fontfile_def *current_ps_fontfile;
     TBOOLEAN doload;
{
    if (current_ps_fontfile) {
	unsigned int linesread = 0;
	FILE *ffont = NULL;
	char line[256];
	char ext[4];
	char cmd[256];
	char *fontname = NULL;
#if defined(PIPES)
	char *envcmd = NULL;
	TBOOLEAN ispipe = FALSE;
#endif
	ext[0] = '\0';
	cmd[0] = '\0';

	if (doload)
	    fprintf(gpoutfile,"%%BeginProcSet: %s\n",
		    current_ps_fontfile->fontfile_name);

	/* get filename extension if no pipe (if pipe *ext=='\0') */
#if defined(PIPES)
	if ( *(current_ps_fontfile->fontfile_name) != '<' ) {
	    /* Filename is given */
#endif
	    if ( strlen(current_ps_fontfile->fontfile_name) > 3 )
		strcpy(ext, current_ps_fontfile->fontfile_name + 
		       strlen(current_ps_fontfile->fontfile_name) - 3);
	    else
		strcpy(ext, current_ps_fontfile->fontfile_name);

	    /* make extension lowercase for comparison */
	    lower_case(ext);
	    
	    if (!current_ps_fontfile->fontfile_fullname)
		int_error(NO_CARET, "Font file '%s' not found",
			  current_ps_fontfile->fontfile_name);
#if defined(PIPES)
	}
#endif
	if ( strlen(ext) == 0 ) {
#if defined(PIPES)
	    /* Pipe is given */
	    ispipe = TRUE;
	    strcpy(cmd,current_ps_fontfile->fontfile_name + 1);
	    ffont = popen(cmd, "r" );
	    if ( !ffont )
		int_error(NO_CARET, "Could not execute pipe '%s'",
			  current_ps_fontfile->fontfile_name + 1 );
#endif
	}
	else if ( strcmp(ext,"ttf") == 0 ) {
	    /* TrueType */
#if defined(PIPES)
	    ispipe = TRUE;
	    envcmd = getenv("GNUPLOT_TTFTOPFA");
	    if (envcmd != NULL)
		sprintf(cmd,envcmd,current_ps_fontfile->fontfile_fullname);
	    else
		sprintf(cmd,"ttf2pt1 -a -e -W 0 %s -",
			current_ps_fontfile->fontfile_fullname);
	    if (strlen(cmd) == 0)
		int_error(NO_CARET, 
			  "No command for automatic font conversion ttf->pfa defined");
	    else {
		ffont = popen(cmd,"r");
		if ( !ffont )
		    int_error(NO_CARET,"Could not execute command '%s'", cmd);
	    }
#else
	    os_error(NO_CARET, 
		     "Automatic font conversion ttf->pfa not supported");
#endif
	} else if ( strcmp(ext,"pfb") == 0 ) {
	    /* PFB */
#if defined(PIPES)
	    ispipe = TRUE;
	    envcmd = getenv("GNUPLOT_PFBTOPFA");
	    if (envcmd != NULL)
		sprintf(cmd,envcmd,current_ps_fontfile->fontfile_fullname);
	    else
		sprintf(cmd,"pfbtops %s",
			current_ps_fontfile->fontfile_fullname);
	    if (strlen(cmd) == 0)
		int_error(NO_CARET, 
			  "No command for automatic font conversion pfb->pfa defined");
	    else {
		ffont = popen(cmd,"r");
		if ( !ffont )
		    int_error(NO_CARET,"Could not execute command '%s'", cmd);
	    }
#else
	    os_error(NO_CARET, 
		     "Automatic font conversion pfb->pfa not supported");
#endif
	} else {
	    /* PFA */
	    if ( strcmp(ext,"pfa") != 0 )
		int_warn(NO_CARET, 
			 "Font file '%s' has unknown extension. Assume it is a pfa file", 
			 current_ps_fontfile->fontfile_name);
	    ffont = fopen(current_ps_fontfile->fontfile_fullname, "r");
	    if (!ffont)
		int_error(NO_CARET, "Font file '%s' not found",
			  current_ps_fontfile->fontfile_name);
	}
	/* read the file */
	while (fgets(line,255,ffont)) {
	    /* test file format */
	    if ( (linesread == 0) && 
		 (strstr(line,"%!PS-AdobeFont") != line) &&
		 (strstr(line,"%!FontType1") != line) ) {
#if defined(PIPES)
		if ( ispipe )
		    int_warn(NO_CARET,
			     "Command '%s' seems not to generate PFA data",
			     cmd);
		else
#endif
		    int_warn(NO_CARET, 
			     "Font file '%s' seems not to be a PFA file",
			     current_ps_fontfile->fontfile_name);
	    }
	    /* get fontname */
	    if (strstr(line,"/FontName") == line) {
		char *fnende = NULL;
		fontname = gp_alloc(strlen(line)-9,"load_fontfiles");
		strcpy(fontname,strstr(line+1,"/")+1);
		fnende = strstr(fontname," ");
		*fnende = '\0';
		/* Print font name */
		if (!doload) {
		    if (current_ps_fontfile->fontfile_fullname)
			fprintf(stderr, 
				"Font file '%s' contains the font '%s'. Location:\n   %s\n",
				current_ps_fontfile->fontfile_name, 
				fontname,
				current_ps_fontfile->fontfile_fullname);
		    else
			fprintf(stderr, 
				"Pipe '%s' contains the font '%s'.\n",
				current_ps_fontfile->fontfile_name, 
				fontname);
#if defined(PIPES)
		    /* Stop reading font file in order to save time */
		    /* This does not work for pipes because they give the */
		    /* error message 'broken pipe' */
		    if ( !ispipe )
#endif
			break;
		}
	    }

	    if (doload)
		fputs(line,gpoutfile);

	    ++linesread;
	}
#if defined(PIPES)
	if ( ispipe ) {
	    int exitcode;
	    if ( (exitcode = pclose(ffont)) != 0 )
		int_error(NO_CARET,
			  "Command '%s' generated error, exitcode is %d",
			  cmd, exitcode);
	}
	else
#endif
	    fclose(ffont);

	if (linesread == 0) {
#if defined(PIPES)
	    if ( ispipe )
		int_error(NO_CARET,
			  "Command '%s' generates empty output",
			  cmd);
	    else
#endif
		int_error(NO_CARET, "Font file '%s' is empty",
			  current_ps_fontfile->fontfile_name);
	}
	if (doload)
	    fputs("%%EndProcSet\n",gpoutfile);

	/* Computer Modern Symbol font with corrected baseline if the
	 * font CMEX10 is embedded */
	if ( doload && fontname && (strcmp(fontname,"CMEX10") == 0) ) {
	    fputs("%%BeginProcSet: CMEX10-Baseline\n",gpoutfile);
	    fputs("/CMEX10-Baseline /CMEX10 findfont [1 0 0 1 0 1] makefont\n",
		  gpoutfile);
	    fputs("dup length dict begin {1 index /FID eq {pop pop} {def} ifelse} forall\n", gpoutfile);
	    fputs("currentdict end definefont pop\n", gpoutfile);
	    fputs("%%EndProcSet\n",gpoutfile);
	}

	if (fontname) {
	    free(fontname);
	    fontname = NULL;
	}
    }
}


TERM_PUBLIC void
PS_load_fontfiles(doload)
     TBOOLEAN doload;
{
    struct ps_fontfile_def *current_ps_fontfile=first_ps_fontfile;
    while (current_ps_fontfile) {
	PS_load_fontfile(current_ps_fontfile,doload);
	current_ps_fontfile = current_ps_fontfile->next;
    }
}


TERM_PUBLIC void
PS_common_init(encap, portrait, uses_fonts, xoff, yoff, bb_xmin, bb_ymin, bb_xmax, bb_ymax, dict)
int encap; /* encapsulated or not - 1 for pslatex */
int portrait; /* 1 for pslatex */
int uses_fonts; /* 0 for ps(la)tex */
unsigned int xoff, yoff; /* how much to translate by */
unsigned int bb_xmin, bb_ymin, bb_xmax, bb_ymax; /* bounding box */
const char **dict; /* extra entries for the dictionary */
{
    static const char GPFAR psi1[] = "\
%%%%Creator: gnuplot %s patchlevel %s\n\
%%%%CreationDate: %s\
%%%%DocumentFonts: %s\n";

    static const char GPFAR psi2[] = "\
%%%%EndComments\n\
/gnudict 256 dict def\ngnudict begin\n\
/Color %s def\n\
/Solid %s def\n\
/gnulinewidth %.3f def\n\
/userlinewidth gnulinewidth def\n\
/vshift %d def\n\
/dl {%.1f mul} def\n\
/hpt_ %.1f def\n\
/vpt_ %.1f def\n\
/hpt hpt_ def\n\
/vpt vpt_ def\n\
/Rounded %s def\n";

    static const char GPFAR * GPFAR PS_iso_8859_1_encoding[] = {
"/reencodeISO {\n",
"dup dup findfont dup length dict begin\n",
"{ 1 index /FID ne { def }{ pop pop } ifelse } forall\n",
"currentdict /CharStrings known {\n",
"\tCharStrings /Idieresis known {\n",
"\t\t/Encoding ISOLatin1Encoding def } if\n} if\n",
"currentdict end definefont\n",
"} def\n",
"/ISOLatin1Encoding [\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright\n",
"/parenleft/parenright/asterisk/plus/comma/minus/period/slash\n",
"/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon\n",
"/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N\n",
"/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright\n",
"/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m\n",
"/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/dotlessi/grave/acute/circumflex/tilde/macron/breve\n",
"/dotaccent/dieresis/.notdef/ring/cedilla/.notdef/hungarumlaut\n",
"/ogonek/caron/space/exclamdown/cent/sterling/currency/yen/brokenbar\n",
"/section/dieresis/copyright/ordfeminine/guillemotleft/logicalnot\n",
"/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior\n",
"/acute/mu/paragraph/periodcentered/cedilla/onesuperior/ordmasculine\n",
"/guillemotright/onequarter/onehalf/threequarters/questiondown\n",
"/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla\n",
"/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex\n",
"/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis\n",
"/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute\n",
"/Thorn/germandbls/agrave/aacute/acircumflex/atilde/adieresis\n",
"/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave\n",
"/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex\n",
"/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis\n",
"/yacute/thorn/ydieresis\n",
"] def\n",
NULL };

    static const char GPFAR * GPFAR PS_iso_8859_15_encoding[] = {
"/reencodeISO15 {\n",
"dup dup findfont dup length dict begin\n",
"{ 1 index /FID ne { def }{ pop pop } ifelse } forall\n",
"currentdict /CharStrings known {\n",
"\tCharStrings /Idieresis known {\n",
"\t\t/Encoding ISOLatin15Encoding def } if\n} if\n",
"currentdict end definefont\n",
"} def\n",
"/ISOLatin15Encoding [\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright\n",
"/parenleft/parenright/asterisk/plus/comma/minus/period/slash\n",
"/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon\n",
"/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N\n",
"/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright\n",
"/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m\n",
"/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/dotlessi/grave/acute/circumflex/tilde/macron/breve\n",
"/dotaccent/dieresis/.notdef/ring/cedilla/.notdef/hungarumlaut\n",
"/ogonek/caron/space/exclamdown/cent/sterling/Euro/yen/Scaron\n",
"/section/scaron/copyright/ordfeminine/guillemotleft/logicalnot\n",
"/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior\n",
"/Zcaron/mu/paragraph/periodcentered/zcaron/onesuperior/ordmasculine\n",
"/guillemotright/OE/oe/Ydieresis/questiondown\n",
"/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla\n",
"/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex\n",
"/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis\n",
"/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute\n",
"/Thorn/germandbls/agrave/aacute/acircumflex/atilde/adieresis\n",
"/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave\n",
"/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex\n",
"/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis\n",
"/yacute/thorn/ydieresis\n",
"] def\n",
NULL };

/* Encoding for ISO-8859-2 (also called as Latin-2), with   */
/* minor differences to "true" ISO-8859-2 (*commaaccent     */
/* instead of *cedilla for sStT -> incorrect in ISO-8859-2, */
/* the standard will probably be modified in this respect)  */
/*      Levente NOVÁK <novak@jaguar.dote.hu>                */

    static const char GPFAR * GPFAR PS_iso_8859_2_encoding[] = {
"/reencodeISO2 {\n",
"dup dup findfont dup length dict begin\n",
"{ 1 index /FID ne { def }{ pop pop } ifelse } forall\n",
"currentdict /CharStrings known {\n",
"\tCharStrings /Idieresis known {\n",
"\t\t/Encoding ISOLatin2Encoding def } if\n} if\n",
"currentdict end definefont\n",
"} def\n",
"/ISOLatin2Encoding [\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright\n",
"/parenleft/parenright/asterisk/plus/comma/hyphen/period/slash\n",
"/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon\n",
"/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M\n",
"/N/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright\n",
"/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m\n",
"/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/nbspace/Aogonek/breve/Lslash/currency/Lcaron/Sacute/section\n",
"/dieresis/Scaron/Scommaaccent/Tcaron/Zacute/hyphen/Zcaron/Zdotaccent\n",
"/degree/aogonek/ogonek/lslash/acute/lcaron/sacute/caron/cedilla\n",
"/scaron/scommaaccent/tcaron/zacute/hungarumlaut/zcaron/zdotaccent\n",
"/Racute/Aacute/Acircumflex/Abreve/Adieresis/Lacute/Cacute/Ccedilla\n",
"/Ccaron/Eacute/Eogonek/Edieresis/Ecaron/Iacute/Icircumflex/Dcaron\n",
"/Dcroat/Nacute/Ncaron/Oacute/Ocircumflex/Ohungarumlaut/Odieresis\n",
"/multiply/Rcaron/Uring/Uacute/Uhungarumlaut/Udieresis/Yacute\n",
"/Tcommaaccent/germandbls/racute/aacute/acircumflex/abreve/adieresis\n",
"/lacute/cacute/ccedilla/ccaron/eacute/eogonek/edieresis/ecaron\n",
"/iacute/icircumflex/dcaron/dcroat/nacute/ncaron/oacute/ocircumflex\n",
"/ohungarumlaut/odieresis/divide/rcaron/uring/uacute/uhungarumlaut\n",
"/udieresis/yacute/tcommaaccent/dotaccent\n",
"] def\n",
NULL };

/*   encoding for code page 437                                            */
/*                                                                         */
/*   version 1.0:  - Mainly letters are mapped. The following positions    */
/*   (JFi)           are left blank (undefined):                           */
/*                   -- first 32 positions,                                */
/*                   -- frame characters,                                  */
/*                   -- greek characters,                                  */
/*                   -- some more special characters.                      */
/*                                                                         */
/*   version 1.1:  - added some more special characters                    */
/*                                                                         */
    static const char GPFAR * GPFAR PS_cp_437_encoding[] = {
"/reencodeCP437 {\n",
"dup dup findfont dup length dict begin\n",
"{ 1 index /FID ne { def }{ pop pop } ifelse } forall\n",
"currentdict /CharStrings known {\n",
"\tCharStrings /Idieresis known {\n",
"\t\t/Encoding CP437Encoding def } if\n} if\n",
"currentdict end definefont\n",
"} def\n",
"/CP437Encoding [\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright\n",
"/parenleft/parenright/asterisk/plus/comma/minus/period/slash\n",
"/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon\n",
"/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N\n",
"/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright\n",
"/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m\n",
"/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde/.notdef\n",
"/Ccedilla/udieresis/eacute/acircumflex/adieresis/agrave/aring/ccedilla\n",
"/ecircumflex/edieresis/egrave/idieresis/icircumflex/igrave/Adieresis/Aring\n",
"/Eacute/ae/AE/ocircumflex/odieresis/ograve/ucircumflex/ugrave\n",
"/ydieresis/Odieresis/Udieresis/cent/sterling/yen/.notdef/florin\n",
"/aacute/iacute/oacute/uacute/ntilde/Ntilde/ordfeminine/ordmasculine\n",
"/questiondown/.notdef/logicalnot/onehalf/onequarter/exclamdown/guillemotleft/guillemotright\n",
"/space/space/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/germandbls/.notdef/.notdef/.notdef/.notdef/mu/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/infinity/.notdef/.notdef/.notdef\n",
"/.notdef/plusminus/greaterequal/lessequal/.notdef/.notdef/divide/.notdef\n",
"/degree/bullet/periodcentered/.notdef/nsuperior/twosuperior/.notdef/.notdef\n",
"] def\n",
NULL };

/*   encoding for code page koi8r                                          */
/*                                                                         */
/*   version 1.0:  - Mainly letters are mapped. The following positions    */
/*   (JFi)           are left blank (undefined):                           */
/*                   -- first 32 positions,                                */
/*                   -- frame characters,                                  */
/*                   -- a few special characters.                          */
/*                                                                         */
    static const char GPFAR * GPFAR PS_koi8r_encoding[] = {
"/reencodeKOI8R {\n",
"dup dup findfont dup length dict begin\n",
"{ 1 index /FID ne { def }{ pop pop } ifelse } forall\n",
"currentdict /CharStrings known {\n",
"\tCharStrings /Idieresis known {\n",
"\t\t/Encoding KOI8REncoding def } if\n} if\n",
"currentdict end definefont\n",
"} def\n",
"/KOI8REncoding [\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright\n",
"/parenleft/parenright/asterisk/plus/comma/minus/period/slash\n",
"/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon\n",
"/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N\n",
"/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright\n",
"/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m\n",
"/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde/.notdef\n",
"/SF100000/SF110000/SF010000/SF030000/SF020000/SF040000/SF080000/SF090000\n",
"/SF060000/SF070000/SF050000/SF600000/SF570000/SF610000/SF580000/SF590000\n",
"/SF140000/SF150000/SF160000/SS260000/filledbox/bullet/radical/approxequal\n",
"/lessequal/greaterequal/space/SS270000/degree/twosuperior/periodcentered/divide\n",
"/SF430000/SF240000/SF510000/afii10071/SF520000/SF390000/SF220000/SF210000\n",
"/SF250000/SF500000/SF490000/SF380000/SF280000/SF270000/SF260000/SF360000\n",
"/SF370000/SF420000/SF190000/afii10023/SF200000/SF230000/SF470000/SF480000\n",
"/SF410000/SF450000/SF460000/SF400000/SF540000/SF530000/SF440000/copyright\n",
"/afii10096/afii10065/afii10066/afii10088/afii10069/afii10070/afii10086/afii10068\n",
"/afii10087/afii10074/afii10075/afii10076/afii10077/afii10078/afii10079/afii10080\n",
"/afii10081/afii10097/afii10082/afii10083/afii10084/afii10085/afii10072/afii10067\n",
"/afii10094/afii10093/afii10073/afii10090/afii10095/afii10091/afii10089/afii10092\n",
"/afii10048/afii10017/afii10018/afii10040/afii10021/afii10022/afii10038/afii10020\n",
"/afii10039/afii10026/afii10027/afii10028/afii10029/afii10030/afii10031/afii10032\n",
"/afii10033/afii10049/afii10034/afii10035/afii10036/afii10037/afii10024/afii10019\n",
"/afii10046/afii10045/afii10025/afii10042/afii10047/afii10043/afii10041/afii10044\n",
"] def\n",
NULL };

/*   encoding for code page 850                                            */
/*                                                                         */
/*   version 1.0:  - Mainly letters are mapped. The following positions    */
/*   (JFi)           are left blank (undefined):                           */
/*                   -- first 32 positions,                                */
/*                   -- frame characters,                                  */
/*                   -- a few special characters.                          */
/*                                                                         */
    static const char GPFAR * GPFAR PS_cp_850_encoding[] = {
"/reencodeCP850 {\n",
"dup dup findfont dup length dict begin\n",
"{ 1 index /FID ne { def }{ pop pop } ifelse } forall\n",
"currentdict /CharStrings known {\n",
"\tCharStrings /Idieresis known {\n",
"\t\t/Encoding CP850Encoding def } if\n} if\n",
"currentdict end definefont\n",
"} def\n",
"/CP850Encoding [\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright\n",
"/parenleft/parenright/asterisk/plus/comma/minus/period/slash\n",
"/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon\n",
"/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N\n",
"/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright\n",
"/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m\n",
"/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde/.notdef\n",
"/Ccedilla/udieresis/eacute/acircumflex/adieresis/agrave/aring/ccedilla\n",
"/ecircumflex/edieresis/egrave/idieresis/icircumflex/igrave/Adieresis/Aring\n",
"/Eacute/ae/AE/ocircumflex/odieresis/ograve/ucircumflex/ugrave\n",
"/ydieresis/Odieresis/Udieresis/oslash/sterling/Oslash/multiply/florin\n",
"/aacute/iacute/oacute/uacute/ntilde/Ntilde/ordfeminine/ordmasculine\n",
"/questiondown/registered/logicalnot/onehalf/onequarter/exclamdown/guillemotleft/guillemotright\n",
"/space/space/.notdef/.notdef/.notdef/Aacute/Acircumflex/Agrave\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/cent/yen/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/atilde/Atilde\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/currency\n",
"/eth/Eth/Ecircumflex/Edieresis/Egrave/dotlessi/Iacute/Icircumflex\n",
"/Idieresis/.notdef/.notdef/.notdef/.notdef/brokenbar/Igrave/.notdef\n",
"/Oacute/germandbls/Ocircumflex/Ograve/otilde/Otilde/mu/thorn\n",
"/Thorn/Uacute/Ucircumflex/Ugrave/yacute/Yacute/macron/acute\n",
"/hyphen/plusminus/equal/threequarters/paragraph/section/divide/.notdef\n",
"/degree/.notdef/periodcentered/onesuperior/threesuperior/twosuperior/.notdef/.notdef\n",
"] def\n",
NULL };

/*   encoding for code page 852             */
/*   Petr Mikulik <mikulik@physics.muni.cz> */

    static const char GPFAR * GPFAR PS_cp_852_encoding[] = {
"/reencodeCP852 {\n",
"dup dup findfont dup length dict begin\n",
"{ 1 index /FID ne { def }{ pop pop } ifelse } forall\n",
"currentdict /CharStrings known {\n",
"\tCharStrings /Idieresis known {\n",
"\t\t/Encoding CP852Encoding def } if\n} if\n",
"currentdict end definefont\n",
"} def\n",
"/CP852Encoding [\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/paragraph/.notdef/.notdef/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef\n",
"/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quotesingle\n",
"/parenleft/parenright/asterisk/plus/comma/hyphen/period/slash\n",
"/zero/one/two/three/four/five/six/seven/eight/nine\n",
"/colon/semicolon/less/equal/greater/question\n",
"/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N/O/P/Q/R/S/T/U/V/W/X/Y/Z\n",
"/bracketleft/backslash/bracketright/asciicircum/underscore\n",
"/grave/a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w\n",
"/x/y/z/braceleft/bar/braceright/asciitilde/.notdef\n",
"/Ccedilla/udieresis/eacute/acircumflex/adieresis/uring/cacute/ccedilla\n",
"/lslash/edieresis/Ohungarumlaut/ohungarumlaut/icircumflex/Zacute/Adieresis\n",
"/Cacute/Eacute/Lacute/lacute/ocircumflex/odieresis/Lcaron/lcaron/Sacute\n",
"/sacute/Odieresis/Udieresis/Tcaron/tcaron/Lslash/multiply/ccaron\n",
"/aacute/iacute/oacute/uacute/Aogonek/aogonek/Zcaron/zcaron\n",
"/Eogonek/eogonek/.notdef/zacute/Ccaron/scedilla/guillemotleft/guillemotright\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/Aacute/Acircumflex/Ecaron\n",
"/Scedilla/.notdef/.notdef/.notdef/.notdef/Zdotaccent/zdotaccent/.notdef\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/Abreve/abreve\n",
"/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/currency\n",
"/eth/Eth/Dcaron/Edieresis/dcaron/Ncaron/Iacute/Icircumflex\n",
"/ecaron/.notdef/.notdef/.notdef/.notdef/Tcedilla/Uring/.notdef\n",
"/Oacute/germandbls/Ocircumflex/Nacute/nacute/ncaron/Scaron/scaron\n",
"/Racute/Uacute/racute/Uhungarumlaut/yacute/Yacute/tcedilla/acute\n",
"/hyphen/hungarumlaut/ogonek/caron/breve/section/divide/cedilla\n",
"/degree/dieresis/dotaccent/uhungarumlaut/Rcaron/rcaron/.notdef/.notdef\n",
"] def\n",
NULL };

    struct termentry *t = term;
    int i;
    time_t now;

    ps_common_encap = encap; /* store for later */
    ps_common_portrait = portrait; /* store for later */
    ps_common_uses_fonts = uses_fonts;
    ps_common_xoff = xoff;
    ps_common_yoff = yoff;

    ps_page = 0;

    if (!encap)
	fputs("%!PS-Adobe-2.0\n", gpoutfile);
    else
	fputs("%!PS-Adobe-2.0 EPSF-2.0\n", gpoutfile);

    if (outstr) fprintf(gpoutfile, "%%%%Title: %s\n", outstr );   /*  JFi  */
    time(&now);
    fprintf(gpoutfile, psi1, gnuplot_version, gnuplot_patchlevel,
	    asctime(localtime(&now)), uses_fonts ? "(atend)" : "");

    fprintf(gpoutfile,"%%%%BoundingBox: %d %d %d %d\n",
	    xoff + bb_xmin, yoff + bb_ymin, xoff + bb_xmax, yoff + bb_ymax);

    fprintf(gpoutfile,"%%%%Orientation: %s\n",
	    ps_portrait ? "Portrait" : "Landscape");

    if (!encap)
	fputs("%%Pages: (atend)\n", gpoutfile);
    fprintf(gpoutfile, psi2,
	    ps_color ? "true" : "false",
	    ps_solid ? "true" : "false",
	    PS_LW*ps_linewidth_factor,	/* line width */
	    (int)(t->v_char)/(-3),	/* shift for vertical centring */
	    PS_SC*ps_dash_length,	/* dash length */
	    PS_HTIC/2.0,		/* half point width */
	    PS_VTIC/2.0,		/* half point height */
	    ps_rounded ? "true" : "false");

    if (uses_fonts && (encoding == S_ENC_ISO8859_1)) {
	for (i = 0; PS_iso_8859_1_encoding[i] != NULL; i++) {
	    fprintf(gpoutfile,"%s",PS_iso_8859_1_encoding[i]);
	}
    }
    if (uses_fonts && (encoding == S_ENC_ISO8859_2)) {
	for (i = 0; PS_iso_8859_2_encoding[i] != NULL; i++) {
	    fprintf(gpoutfile,"%s",PS_iso_8859_2_encoding[i]);
	}
    }
    if (uses_fonts && (encoding == S_ENC_ISO8859_15)) {
	for (i = 0; PS_iso_8859_15_encoding[i] != NULL; i++) {
	    fprintf(gpoutfile,"%s",PS_iso_8859_15_encoding[i]);
	}
    }
    if (uses_fonts && (encoding == S_ENC_CP437)) {       /* JFi */
	for (i = 0; PS_cp_437_encoding[i] != NULL; i++) {
	    fprintf(gpoutfile,"%s",PS_cp_437_encoding[i]);
	}
    }
    if (uses_fonts && (encoding == S_ENC_CP850)) {       /* JFi */
	for (i = 0; PS_cp_850_encoding[i] != NULL; i++) {
	    fprintf(gpoutfile,"%s",PS_cp_850_encoding[i]);
	}
    }
    if (uses_fonts && (encoding == S_ENC_CP852)) {
	for (i = 0; PS_cp_852_encoding[i] != NULL; i++) {
	    fprintf(gpoutfile,"%s",PS_cp_852_encoding[i]);
	}
    }
    if (uses_fonts && (encoding == S_ENC_KOI8_R)) {
	for (i = 0; PS_koi8r_encoding[i] != NULL; i++) {
	    fprintf(gpoutfile,"%s",PS_koi8r_encoding[i]);
	}
    }
    /* Duplicate code! 
     * As long as only two code pages are implemented, that's not a big 
     * problem. Otherwise a small procedure might be beneficial.
     */

    for ( i = 0; PS_header[i] != NULL; i++)
	fprintf(gpoutfile,"%s",PS_header[i]);
    if (ps_duplex_option)
	fprintf(gpoutfile, "statusdict begin %s setduplexmode end\n",
		ps_duplex_state ? "true" : "false");

    if (dict)
	while (*dict)
	    fputs(*(dict++), gpoutfile);	

    PS_load_fontfiles(TRUE);

    if (uses_fonts)
	PS_RememberFont(ps_font, 1);

    fputs("end\n%%EndProlog\n", gpoutfile);
}

/* the init fn for the postscript driver */
TERM_PUBLIC void
PS_init()
{
    unsigned int xmin_t, ymin_t, xmax_t, ymax_t;

    if (ps_eps) {
	term->xmax = PS_XMAX;
	term->ymax = PS_YMAX;
	xmin_t = PS_XMAX * xoffset / (2*PS_SC);
	xmax_t = PS_XMAX * (xsize + xoffset) / (2*PS_SC);
	ymin_t = PS_YMAX * yoffset / (2*PS_SC);
	ymax_t = PS_YMAX * (yoffset + ysize) / (2*PS_SC);
    } else if (ps_portrait) {
	term->xmax = PS_YMAX;
	term->ymax = PS_XMAX;
	xmin_t = PS_YMAX * xoffset / PS_SC;
	xmax_t = PS_YMAX * (xsize + xoffset) / PS_SC;
	ymin_t = PS_XMAX * yoffset / PS_SC;
	ymax_t = PS_XMAX * (ysize + yoffset) / PS_SC;
    } else {
	term->xmax = PS_XMAX;
	term->ymax = PS_YMAX;
	ymin_t = PS_XMAX * xoffset / PS_SC;
	ymax_t = PS_XMAX * (xsize+xoffset) / PS_SC;
	xmin_t = PS_YMAX * (1-ysize-yoffset) / PS_SC;
	xmax_t = PS_YMAX * (1-yoffset) / PS_SC;
    }

    /* for enhanced postscript, copy ps_font to ps_enh_font
     * does no harm for non-enhanced
     */
    strcpy(ps_enh_font, ps_font);
    ps_enh_fontsize = ps_fontsize;

    PS_common_init(ps_eps, ps_portrait, 1, PS_XOFF, PS_YOFF,
		   xmin_t, ymin_t, xmax_t, ymax_t,
		   (term->put_text == ENHPS_put_text) ? ENHPS_header : NULL);
#ifdef PM3D
    /* to optimize output for postscript terminals family */
    postscript_gpoutfile = gpoutfile;
#endif
}


TERM_PUBLIC void
PS_graphics()
{
    static char GPFAR psg1[] = "0 setgray\nnewpath\n";
    struct termentry *t = term;
    ps_page++;
    if (!ps_common_encap)
	fprintf(gpoutfile,"%%%%Page: %d %d\n",ps_page,ps_page);
    fprintf(gpoutfile,"\
gnudict begin\ngsave\n\
%d %d translate\n\
%.3f %.3f scale\n",
	    ps_common_xoff, ps_common_yoff,
	    (ps_eps ? 0.5 : 1.0)/PS_SC,
	    (ps_eps ? 0.5 : 1.0)/PS_SC);
    if (!ps_common_portrait) {
	fprintf(gpoutfile,"90 rotate\n0 %d translate\n", (int)(-PS_YMAX));
    }
    fprintf(gpoutfile, psg1);
    if (ps_common_uses_fonts)
	fprintf(gpoutfile, "(%s) findfont %d scalefont setfont\n",
		ps_font, (t->v_char) );
    ps_path_count = 0;
    PS_relative_ok = FALSE;
    PS_pen_x = PS_pen_y = -4000;
    PS_taken = 0;
    PS_linetype_last = -1;
}


TERM_PUBLIC void
PS_text()
{
    ps_path_count = 0;
    fprintf(gpoutfile,"stroke\ngrestore\nend\nshowpage\n");
    /* fprintf(stderr,"taken %d times\n",PS_taken); */
    /* informational:  tells how many times it was "cheaper"
     * to do a relative moveto or lineto rather than an
     * absolute one */
}


TERM_PUBLIC void
PS_reset()
{
    fputs("%%Trailer\n", gpoutfile);

    /* I think the following commands should be executed 
       `if (ps_common_uses_fonts)`. So I changed the next line. 
       Please see "PS_RememberFont", too.                       */  /* JFi */

    /*	if (!ps_common_uses_fonts) {  */                             /* JFi */
    if (ps_common_uses_fonts) {
	fputs("%%DocumentFonts: ", gpoutfile);
	while (PS_DocFonts) {
	    struct PS_FontName *fnp;
	    fnp = PS_DocFonts->next;
	    fprintf(gpoutfile, "%s%s", PS_DocFonts->name, fnp ? " " : "\n");
	    free(PS_DocFonts->name);
	    free(PS_DocFonts);
	    PS_DocFonts = fnp;
	}
    }
    if (!ps_common_encap)
	fprintf(gpoutfile,"%%%%Pages: %d\n",ps_page);
}


TERM_PUBLIC void
PS_linetype(linetype)
    int linetype;
{
    linetype = (linetype % 9) + 3;
    if (linetype < 0)	/* LT_NODRAW, LT_BACKGROUND, LT_UNDEFINED */
	linetype = 0;
    PS_relative_ok = FALSE;

#if 0
    /*  In order to make 'PS_linewidth' work properly, I need to comment
     *  this line out.  Especially in combination with the line width
     *  extension of the `set arrow` command this is necessary.
     *  Can we live with that drawback?  (JFi)
     */
    if (PS_linetype_last == linetype) return;
#endif
    PS_linetype_last = linetype;
    fprintf(gpoutfile,"LT%c\n", "wba012345678"[linetype]);
    ps_path_count = 0;
}


TERM_PUBLIC void
PS_linewidth (linewidth)
double linewidth;
{
        fprintf(gpoutfile,"%.3f UL\n",linewidth);

/*  
  Documentation of the 'change linewidth' strategy of the postscript terminal:

  1. define a new postscript variable with a default value:
     /userlinewidth gnulinewidth def

  2. define a new postscript command to change the contents of that variable:
     /UL { gnulinewidth mul /userlinewidth exch def } def
     usage:  multiplication_factor UL

  3. modify the already known postscript command /PL for the plot lines:
     /PL { stroke userlinewidth setlinewidth } def

  4. issue the new command before every change of the plot linestyle:
     example:
         4.0 UL
         LT0
     result:
         Linetype 0 is drawn four times as thick as defined by the contents
         of the postscript variable 'gnulinewidth'.
*/
}


TERM_PUBLIC void
PS_pointsize (ptsize)
double ptsize;
{
    fprintf(gpoutfile,"%.3f UP\n",ptsize);

/*  
 *  Documentation of the 'change pointsize' strategy of the postscript
 * terminal:
 *
 * 1. define two new postscript variables to hold the overall pointsize:
 *    /hpt_  and  /vpt_
 *
 * 2. define a new postscript command to use the contents of these variables: 
 *    /UP { cf. definition above } def
 *    usage:  multiplication_factor UP
 *
 * [3.] [doesn't exist, skip to next number]
 *
 * 4. issue the new command whereever you change the symbols (and linetype):
 *    example:
 *        2.5 UP
 *        4.0 UL  % optionally change linewidth, too
 *        LT0
 *    result:
 *        Next symbols will be drawn 2.5 times as big as defined by the 
 *        GNUPLOT `set pointsize` command (= overall pointsize).
 */
}


TERM_PUBLIC void
PS_move(x,y)
    unsigned int x,y;
{
    /* Make this semi-dynamic and independent of architecture */
    char abso[5+2*INT_STR_LEN], rel[5+2*INT_STR_LEN];
    int dx = x - PS_pen_x;
    int dy = y - PS_pen_y;

    /* can't cancel all null moves--need a move after stroke'ing */
    if (dx==0 && dy==0 && PS_relative_ok)
	return;

    sprintf(abso, "%d %d M\n", x, y);
    sprintf(rel, "%d %d R\n", dx, dy);

    if (strlen(rel) < strlen(abso) && PS_relative_ok) {
	fputs(rel, gpoutfile);
	PS_taken++;
    } else
	fputs(abso, gpoutfile);
    PS_relative_ok = TRUE;
    ps_path_count += 1;

    PS_pen_x = x;
    PS_pen_y = y;
}

TERM_PUBLIC void
PS_vector(x,y)
    unsigned int x,y;
{
    char abso[5+2*INT_STR_LEN], rel[5+2*INT_STR_LEN];
    int dx = x - PS_pen_x;
    int dy = y - PS_pen_y;

    if (dx==0 && dy==0)
	return;

    sprintf(abso, "%d %d L\n", x, y);
    sprintf(rel, "%d %d V\n", dx, dy);
    
    /* The following PS_move() is executed only when the limit of ps_path_count
     * has been reached below: then PS_FLUSH_PATH has been called which has not
     * moved to currentpoint after the stroke. */
    if (!PS_relative_ok)
	PS_move(PS_pen_x, PS_pen_y);
    
    if (strlen(rel) < strlen(abso)) {
	fputs(rel, gpoutfile);
	PS_taken++;
    } else
	fputs(abso, gpoutfile);

    PS_relative_ok = TRUE;
    ps_path_count += 1;
    PS_pen_x = x;
    PS_pen_y = y;
    /* Ghostscript has a "pile-up of rounding errors" bug: a sequence of many
     * rmove's or rlineto's does not give the same line made aby move's or 
     * lineto's.
     * Therefore, let us do a stroke very often. There was a case when 400
     * rlineto's were too much, so let's go a little bit higher than the default
     * function sampling rate in gnuplot. */
    if (ps_path_count >= 105) {
#if 0 /* Code up to February 2003: it uses the current position as calculated
       * by the RIP. */
	fputs("currentpoint stroke M\n", gpoutfile);
	ps_path_count = 0;
#else
	/* Don't rely on RIP's value of the current position due to the
	 * above-mentioned bug in ghostscript. A macro is used to make a stroke
	 * and then let PS_relative_ok=FALSE so that the next call to
	 * PS_vector() starts with an absolute position of the current
	 * PS_vector(). */
	PS_FLUSH_PATH;
#endif
    }
}


TERM_PUBLIC void
PS_put_text(x,y,str)
    unsigned int x, y;
    const char *str;
{
    char ch;

    if (!str && !strlen(str))
	return;
    PS_move(x,y);
    if (ps_blacktext)
	fputs("gsave 0 setgray\n", gpoutfile);
    if (ps_ang != 0)
	fprintf(gpoutfile,"currentpoint gsave translate %d rotate 0 0 M\n",
		ps_ang);
    putc('(',gpoutfile);
    ch = *str++;
    while(ch!='\0') {
	if ( (ch=='(') || (ch==')') || (ch=='\\') )
	    putc('\\',gpoutfile);
	putc(ch,gpoutfile);
	ch = *str++;
    }

    switch(ps_justify) {
    case LEFT :
	fputs(") Lshow\n", gpoutfile);
	break;
    case CENTRE :
	fputs(") Cshow\n", gpoutfile);
	break;
    case RIGHT :
	fputs(") Rshow\n", gpoutfile);
	break;
    }
    if (ps_ang != 0 || ps_blacktext)
	fputs("grestore\n", gpoutfile);
    if (ps_ang != 0 && ps_blacktext)
	fputs("grestore\n", gpoutfile);
    ps_path_count = 0;
    PS_relative_ok = FALSE;
}


TERM_PUBLIC int
PS_text_angle(ang)
int ang;
{
    ps_ang = ang;
    return TRUE;
}


TERM_PUBLIC int
PS_justify_text(mode)
enum JUSTIFY mode;
{
    ps_justify = mode;
    return TRUE;
}


TERM_PUBLIC int
PS_set_font(font)  /* Entry font added by DJL */
const char *font;
{
    char name[32];
    int  i,size;
    size_t sep;

    if (!font || !(*font))
	font = PS_default_font;
    sep = strcspn(font,",");
    strncpy(name,font,sep);
    name[sep] = NUL;
    for (i=0; i<sep; i++)
	if (name[i] == ' ') name[i] = '-';
    size = ps_fontsize;
    if (font[sep] == ',')
	sscanf (&(font[sep+1]),"%d",&size);
    PS_RememberFont(name,1 );
    fprintf(gpoutfile,"/%s findfont %d scalefont setfont\n",name,size*PS_SC);
    term->v_char = (unsigned int)(size*PS_SC);
    term->h_char = (unsigned int)(size*PS_SC*6/10);
    return TRUE;
}


/* postscript point routines */


TERM_PUBLIC void
PS_point(x,y,number)
unsigned int x,y;
int number;
{
    static const char GPFAR * GPFAR pointFNS[] = {
	"Pnt",  "Pls",   "Crs",    "Star",
	"Box",  "BoxF",  "Circle", "CircleF",
	"TriU", "TriUF", "TriD",   "TriDF",
	"Dia",  "DiaF",  "Pent",   "PentF",
	"C0",   "C1",    "C2",     "C3",
	"C4",   "C5",    "C6",     "C7",
	"C8",   "C9",    "C10",    "C11",
	"C12",  "C13",   "C14",    "C15",
	"S0",   "S1",    "S2",     "S3",
	"S4",   "S5",    "S6",     "S7",
	"S8",   "S9",    "S10",    "S11",
	"S12",  "S13",   "S14",    "S15",
	"D0",   "D1",    "D2",     "D3",
	"D4",   "D5",    "D6",     "D7",
	"D8",   "D9",    "D10",    "D11",
	"D12",  "D13",   "D14",    "D15",
	"BoxE", "CircE", "TriUE",  "TriDE",
	"DiaE", "PentE", "BoxW",   "CircW",
	"TriUW", "TriDW", "DiaW",  "PentW"
};
    if (number < 0)
	number = -1;		/* negative types are all 'dot' */
    else
	number %= sizeof(pointFNS)/sizeof(pointFNS[0]) -1;
    fprintf(gpoutfile,"%d %d %s\n", x, y, pointFNS[number+1]);

    PS_relative_ok = FALSE;
    ps_path_count = 0;
    PS_linetype_last = -1; /* force next linetype change */
}

TERM_PUBLIC void
PS_fillbox(style, x1,y1,width,height)
    int style;
    unsigned int x1,y1,width,height;
{
#if USE_ULIG_FILLEDBOXES
    double filldens;
    int pattern;
#endif /* USE_ULIG_FILLEDBOXES */

    PS_FLUSH_PATH;

#if USE_ULIG_FILLEDBOXES
    switch( style & 0xf ) {
    
    case FS_SOLID:
	/* style == 1 --> fill with intensity according to filldensity */
        filldens = (style >> 4) / 100.0;
        if( filldens < 0.0 )
	    filldens = 0.0;
        if( filldens > 1.0 )
	    filldens = 1.0;
        fprintf(gpoutfile, "%.3f %d %d %d %d BoxColFill\n",
		filldens, x1,y1, width,height);
        break;
	
    case FS_PATTERN: 
	/* style == 2 --> fill with pattern according to fillpattern */
	/* the upper 3 nibbles of 'style' contain pattern number */
	pattern = (style >> 4) % 8;
	switch (pattern) {

	default:
	case 0:
		fprintf(gpoutfile, "%d %d %d %d BoxFill\n", x1, y1, width, height);
		break;
	case 1:
		fprintf(gpoutfile, "%d %d %d %d %d %d 1 PatternFill\n",
			x1, y1, width, height, 80, -45);
		break;
	case 2:
		fprintf(gpoutfile, "%d %d %d %d %d %d 2 PatternFill\n",
			x1, y1, width, height, 40,  45);
		break;
	case 3:
		fprintf(gpoutfile, "1 %d %d %d %d BoxColFill\n", x1, y1, width, height);
		break;
	case 4:
		fprintf(gpoutfile, "%d %d %d %d %d %d 0 PatternFill\n",
			x1, y1, width, height, 80,  45);
		break;
	case 5:
		fprintf(gpoutfile, "%d %d %d %d %d %d 0 PatternFill\n",
			x1, y1, width, height, 80, -45);
		break;
	case 6:
		fprintf(gpoutfile, "%d %d %d %d %d %d 0 PatternFill\n",
			x1, y1, width, height, 40,  30);
		break;
	case 7:
		fprintf(gpoutfile, "%d %d %d %d %d %d 0 PatternFill\n",
			x1, y1, width, height, 40, -30);
		break;
	}
        break; /* end of pattern filling part */ 
	
    default: /* style == 0 or unknown --> fill with background color */
        fprintf(gpoutfile, "%d %d %d %d BoxFill\n", x1, y1, width, height);
    }
#else  /* USE_ULIG_FILLEDBOXES */
        fprintf(gpoutfile, "%d %d %d %d BoxFill\n", x1, y1, width, height);
#endif /* USE_ULIG_FILLEDBOXES */

    PS_relative_ok = FALSE;
    PS_linetype_last = -1;
}


/* ENHPOST */

static TBOOLEAN ENHps_opened_string;  /* try to cut out empty ()'s */

/*
 * close a postscript string if it has been opened
 */
TERM_PUBLIC void 
ENHPS_FLUSH()
{
    if (ENHps_opened_string) {
	fputs(")]\n", gpoutfile);
	ENHps_opened_string = FALSE;
    }
}

/*
 * open a postscript string
 */
TERM_PUBLIC void 
ENHPS_OPEN(fontname, fontsize, base, widthflag, showflag, overprint)
    char *fontname;
    TBOOLEAN widthflag, showflag;
    double fontsize, base;
    int overprint;
{
	if (!ENHps_opened_string) {
	    fprintf(gpoutfile, "[(%s) %.1f %.1f %s %s %d (",
		    fontname, fontsize, base,
		    widthflag ? "true" : "false",
		    showflag ? "true" : "false",
		    overprint);
	    ENHps_opened_string = TRUE;
	}
}

/*
 * write one or more characters from inside enhanced text processing
 */
TERM_PUBLIC void 
ENHPS_WRITEC(char c)
{
    fputc(c, gpoutfile);
}

/* a set-font routine for enhanced post : simply copies
 * the font into a global, or restores the globals
 * to the ps_font default
 */

TERM_PUBLIC int
ENHPS_set_font(font)  /* Entry font added by DJL */
const char *font;
{
    if (ignore_enhanced_text)
	return PS_set_font(font);

    if (*font) {
	size_t sep = strcspn(font,",");
	strncpy(ps_enh_font,font,sep);
	ps_enh_font[sep] = NUL;
	ps_enh_fontsize = ps_fontsize;
	sscanf (font+sep+1,"%d",&ps_enh_fontsize);
	PS_RememberFont(ps_enh_font, 1);
    } else {
	/* return to defaults */
	strcpy(ps_enh_font, ps_font);
	ps_enh_fontsize = ps_fontsize;
    }
    term->v_char = (unsigned int)(ps_enh_fontsize*PS_SC);
    term->h_char = (unsigned int)(ps_enh_fontsize*PS_SC*6/10);

    return TRUE;
}

TERM_PUBLIC void
ENHPS_put_text(x, y, str)
    unsigned int x, y;
    const char *str;
{
    if (ignore_enhanced_text) {
	PS_put_text(x,y,str);
	return;
    }

    /* flush any pending graphics (all the XShow routines do this...) */

    if (!strlen(str))
	return;

    PS_FLUSH_PATH;

    /* if there are no magic characters, we should just be able
     * punt the string to PS_put_text(), which will give shorter
     * ps output [eg tics and stuff rarely need extra processing],
     * but we need to make sure that the current font is the
     * default one before we can do that. {ie I tried it and it
     * used the wrong font !}
     * if (!strpbrk(str, "{}^_@&~"))
     * {
     *   - do something to ensure default font is selected
     *   PS_put_text(x,y,str);
     *   return;
     * }
     */

    PS_move(x,y);

    if (ps_blacktext)
	fputs("gsave 0 setgray\n", gpoutfile);
    if (ps_ang != 0)
	fprintf(gpoutfile,"currentpoint gsave translate %d rotate 0 0 moveto\n",
		ps_ang);

    fputs("[ ", gpoutfile);

    /* set up the global variables needed by enhanced_recursion() */
    enhanced_max_height = -1000;
    enhanced_min_height = 1000;
    enhanced_fontscale = PS_SC;
    strncpy(enhanced_escape_format,"\\%o",sizeof(enhanced_escape_format));

    ENHps_opened_string = FALSE;

    /* Set the recursion going. We say to keep going until a
     * closing brace, but we don't really expect to find one.
     * If the return value is not the nul-terminator of the
     * string, that can only mean that we did find an unmatched
     * closing brace in the string. We increment past it (else
     * we get stuck in an infinite loop) and try again.
     *
     * ps_enh_font and ps_enh_fontsize are either set to the
     * the defaults set on option line, or have been set to
     * "font,size". That is to say, ps_font is used only
     * at startup and by ENHPS_set_font
     */
    while (*(str = enhanced_recursion((char *)str, TRUE, ps_enh_font,
		 (double)(ps_enh_fontsize*PS_SC), 0.0, TRUE, TRUE, 0))) {
	ENHPS_FLUSH();

	/* I think we can only get here if *str == '}' */
	enh_err_check(str);

	if (!*++str)
	    break; /* end of string */

	/* else carry on and process the rest of the string */
    }

    enhanced_max_height += enhanced_min_height;

    fprintf(gpoutfile, "] %.1f ", -enhanced_max_height/3);

    switch(ps_justify) {
    case LEFT :
	fputs("MLshow\n", gpoutfile);
	break;
    case CENTRE :
	fputs("MCshow\n", gpoutfile);
	break;
    case RIGHT :
	fputs("MRshow\n", gpoutfile);
	break;
    }

    if (ps_ang != 0 || ps_blacktext)
	fputs("grestore\n", gpoutfile);
    if (ps_ang != 0 && ps_blacktext)
	fputs("grestore\n", gpoutfile);
    ps_path_count = 0;
    PS_relative_ok = FALSE;
}


#ifdef PM3D


static void make_palette_formulae()
{
#define R sm_palette.formulaR
#define G sm_palette.formulaG
#define B sm_palette.formulaB
/* print the definition of R,G,B formulae */
  fputs("/InterpolatedColor false def\n",gpoutfile);
if (sm_palette.ps_allcF == 0) { /* print only those 3 used formulae */
    fprintf( gpoutfile, "/cF%i {%s} bind def\t%% %s\n", 
	     abs(R), ps_math_color_formulae[ 2*abs(R) ], 
	     ps_math_color_formulae[ 2*abs(R)+1 ]);
    if (abs(G) != abs(R))
      fprintf( gpoutfile, "/cF%i {%s} bind def\t%% %s\n", 
	       abs(G), ps_math_color_formulae[ 2*abs(G) ], 
	       ps_math_color_formulae[ 2*abs(G)+1 ]);
    if ((abs(B) != abs(R)) && (abs(B) != abs(G)))
      fprintf( gpoutfile, "/cF%i {%s} bind def\t%% %s\n", 
	       abs(B), ps_math_color_formulae[ 2*abs(B) ], 
	       ps_math_color_formulae[ 2*abs(B)+1 ]);
    }
  else { /* all color formulae are written into the output PostScript file */
    int i = 0;
    while ( *(ps_math_color_formulae[2*i]) ) {
      fprintf( gpoutfile, "/cF%i {%s} bind def\t%% %s\n", 
	       i, ps_math_color_formulae[ 2*i ], 
	       ps_math_color_formulae[ 2*i+1 ]);
      i++;
      }
    }
#undef R
#undef G
#undef B
}



static void make_interpolation_code()
{
  static const char *header[] = {
    "/grayindex {/gidx 0 def\n",
    "  {GrayA gidx get grayv ge {exit} if /gidx gidx 1 add def} loop} def\n",
    "/dgdx {grayv GrayA gidx get sub GrayA gidx 1 sub get\n",
    "  GrayA gidx get sub div} def \n",
    "/redvalue {RedA gidx get RedA gidx 1 sub get\n",
    "  RedA gidx get sub dgdxval mul add} def\n",
    "/greenvalue {GreenA gidx get GreenA gidx 1 sub get\n",
    "  GreenA gidx get sub dgdxval mul add} def\n",
    "/bluevalue {BlueA gidx get BlueA gidx 1 sub get\n",
    "  BlueA gidx get sub dgdxval mul add} def\n",
    "/interpolate {\n",
    "  grayindex grayv GrayA gidx get sub abs 1e-5 le\n",
    "    {RedA gidx get GreenA gidx get BlueA gidx get}\n",
    "    {/dgdxval dgdx def redvalue greenvalue bluevalue} ifelse} def\n",
    NULL,
  };
  int i;
  for( i=0; header[i]!=NULL; ++i ) {
    fputs( header[i], gpoutfile );
  }
}


static void make_color_model_code()
{
    /* Postscript version of the color space transformations in getcolor.c */
    static const char *header[] = {
"/HSV2RGB {",
"  exch dup 0.0 eq {pop exch pop dup dup} % achromatic gray\n",
"  { /HSVs exch def /HSVv exch def 6.0 mul dup floor dup 3 1 roll sub\n ",
"    /HSVf exch def /HSVi exch cvi def /HSVp HSVv 1.0 HSVs sub mul def\n",
"	 /HSVq HSVv 1.0 HSVs HSVf mul sub mul def \n",
"	 /HSVt HSVv 1.0 HSVs 1.0 HSVf sub mul sub mul def\n",
"	 /HSVi HSVi 6 mod def 0 HSVi eq {HSVv HSVt HSVp}\n",
"	 {1 HSVi eq {HSVq HSVv HSVp}{2 HSVi eq {HSVp HSVv HSVt}\n",
"	 {3 HSVi eq {HSVp HSVq HSVv}{4 HSVi eq {HSVt HSVp HSVv}\n",
"	 {HSVv HSVp HSVq} ifelse} ifelse} ifelse} ifelse} ifelse\n",
"  } ifelse} def\n",
"/Constrain {\n",
"  dup 0 lt {0 exch pop}{dup 1 gt {1 exch pop} if} ifelse} def\n",
"/YIQ2RGB {\n",
"  3 copy -1.702 mul exch -1.105 mul add add Constrain 4 1 roll\n",
"  3 copy -0.647 mul exch -0.272 mul add add Constrain 5 1 roll\n",
"  0.621 mul exch -0.956 mul add add Constrain 3 1 roll } def\n",
"/CMY2RGB {",
"  1 exch sub exch 1 exch sub 3 2 roll 1 exch sub 3 1 roll exch } def\n",
"/XYZ2RGB {",
"  3 copy -0.9017 mul exch -0.1187 mul add exch 0.0585 mul exch add\n",
"  Constrain 4 1 roll 3 copy -0.0279 mul exch 1.999 mul add exch\n",
"  -0.9844 mul add Constrain 5 1 roll -0.2891 mul exch -0.5338 mul add\n",
"  exch 1.91 mul exch add Constrain 3 1 roll} def\n",
"/SelectSpace {ColorSpace (HSV) eq {HSV2RGB}{ColorSpace (XYZ) eq {\n",
"  XYZ2RGB}{ColorSpace (CMY) eq {CMY2RGB}{ColorSpace (YIQ) eq {YIQ2RGB}\n",
"  if} ifelse} ifelse} ifelse} def\n",
        NULL,
    };
    int i;
    for( i=0; header[i]!=NULL; ++i ) {
        fputs( header[i], gpoutfile );
    }
}


static char *save_space( double gray )
{
    /* printing the gray with 4 digits and without the leading 0 
     * ... saving space */
    static char s[40];

    gray = 0.0001*(int)(gray*10000+0.5); /* round it to 4 digits */
    sprintf( s, "%.4g", gray );
    if ( s[0] == '0' && s[1] == '.' ) 
        return &(s[1]);  /* strip leading 0 */
    else
        return s;
}


static void write_color_space( t_sm_palette *palette )
{
    /* write something like
     *   /ColorSpace (HSV) def
     * depending on the selcted cmodel in palette */
    fputs( "/ColorSpace ", gpoutfile );
    switch( palette->cmodel ) {
      case C_MODEL_RGB: fputs( "(RGB)", gpoutfile ); break;
      case C_MODEL_HSV: fputs( "(HSV)", gpoutfile ); break;
      case C_MODEL_CMY: fputs( "(CMY)", gpoutfile ); break;
      case C_MODEL_YIQ: fputs( "(YIQ)", gpoutfile ); break;
      case C_MODEL_XYZ: fputs( "(XYZ)", gpoutfile ); break;
      default:  
	fprintf(stderr,"%s:%d ooops: Unkown color model '%c'. Will be RGB\n",
		__FILE__, __LINE__, (char)(palette->cmodel) );
	fputs( "(RGB)", gpoutfile ); break;
    }
    fputs( " def\n", gpoutfile );
}


static void write_component_array( const char *text, gradient_struct *grad, 
				   int cnt, int offset )
{
    /*  write someting like
     *     /RedA [ 0 .1 .2 .3 .35 .3 .2 .1 0 0 0 ] def
     *  nicely formated to gpoutfile 
     */
    int i=0, len=0;
    char *val;
    fprintf( gpoutfile, "/%s [", text );
    len = strlen(text) + 4;
    for( i=0; i<cnt; ++i) {
        char *ref = (char*)(&(grad[i]));
	ref += offset;
        val = save_space( *((double*)(ref)) );
	len += strlen(val)+1;
	if( len>77 ) { fputs("\n  ",gpoutfile); len = strlen(val)+3; }
	fprintf(gpoutfile, "%s ", val );
    }
    fputs("] def\n", gpoutfile);
}


static void write_gradient_definition( gradient_struct *gradient, int cnt )
{
    /* some strange pointer acrobatic here, but it seems to work... */
    char *ref = (char*)(&(gradient[0]));
    int p = (char*)(&(gradient[0].pos)) - ref;
    int r = (char*)(&(gradient[0].col.r)) - ref;
    int g = (char*)(&(gradient[0].col.g)) - ref;
    int b = (char*)(&(gradient[0].col.b)) - ref;
    
    write_component_array( "GrayA", gradient, cnt, p );
    write_component_array( "RedA", gradient, cnt, r );
    write_component_array( "GreenA", gradient, cnt, g );
    write_component_array( "BlueA", gradient, cnt, b );
}


static void 
PS_make_header(t_sm_palette *palette)
{
    /* write header for smooth colors */
    fputs("gsave %% colour palette begin\n", gpoutfile);
    fprintf(gpoutfile, "/maxcolors %i def\n", sm_palette.use_maxcolors);
    make_color_model_code();

    switch( sm_palette.colorMode ) {
      case SMPAL_COLOR_MODE_GRAY:
	break;  /* nothing to do form gray */
      case SMPAL_COLOR_MODE_RGB:
	make_palette_formulae();
	break;
      case SMPAL_COLOR_MODE_FUNCTIONS: {
	int cnt=0;
	gradient_struct *gradient;
	fputs("/InterpolatedColor true def\n",gpoutfile);
	make_interpolation_code();
	gradient = approximate_palette( palette, ps_palfunc_samples, 
					ps_palfunc_deviation, &cnt );
	write_gradient_definition( gradient, cnt );
	free( gradient );
	break;
      }
      case SMPAL_COLOR_MODE_GRADIENT:
	fputs("/InterpolatedColor true def\n",gpoutfile);
	make_interpolation_code();
	write_gradient_definition( palette->gradient, palette->gradient_num );
	break;
      default:
	fprintf( stderr, "%s:%d ooops: Unknown color mode '%c'\n",
		 __FILE__, __LINE__, (char)(sm_palette.colorMode) );
    }
    fputs("/maxcolorsLast {maxcolors 1 sub maxcolors div} def\n", gpoutfile);
    fputs("/pm3dround {maxcolors 0 gt {dup maxcolorsLast ge {pop 1}\n",
	  gpoutfile);
    fputs( "{maxcolors mul floor maxcolors div} ifelse} if} def\n", gpoutfile);
    fprintf( gpoutfile, "/pm3dGamma 1.0 %g div def\n", sm_palette.gamma );
    write_color_space( palette );

/* Now print something like
/g {dup cF7 exch dup cF5 exch cF15 setrgbcolor} bind def
*/
#define R sm_palette.formulaR
#define G sm_palette.formulaG
#define B sm_palette.formulaB
fprintf(gpoutfile,"Color %s and { %% COLOUR vs. GRAY map\n",
	    (sm_palette.colorMode!=SMPAL_COLOR_MODE_GRAY) ? "true":"false" );
    fputs("  InterpolatedColor { %% Interpolation vs. RGB-Formula\n", gpoutfile);
    fputs("    /g {stroke pm3dround /grayv exch def interpolate\n", gpoutfile);
    fputs("        SelectSpace setrgbcolor} bind def\n", gpoutfile);
    fputs("  }{\n", gpoutfile );
    fputs("  /g {stroke pm3dround dup ", gpoutfile);
    if (R < 0) fputs("1 exch sub ", gpoutfile); /* negate */
    fprintf(gpoutfile,"cF%i Constrain exch dup ", abs(R));
    if (G < 0) fputs("1 exch sub ", gpoutfile); /* negate */
    fprintf(gpoutfile,"cF%i Constrain exch ", abs(G));
    if (R<0 || G<0 || B<0) fputs("\n\t", gpoutfile);
    if (B < 0) fputs("1 exch sub ", gpoutfile); /* negate */
    fprintf(gpoutfile,"cF%i Constrain ", abs(B));
    fputs("\n       SelectSpace setrgbcolor} bind def\n", gpoutfile);
    fputs("  } ifelse\n", gpoutfile );
    fputs("}{\n", gpoutfile);
    fputs("  /g {stroke pm3dround pm3dGamma exp setgray} bind def\n", gpoutfile);
    fputs("} ifelse\n", gpoutfile);
    fputs("/h {rlineto rlineto rlineto fill} bind def\n", gpoutfile);
#undef R
#undef G
#undef B
}


TERM_PUBLIC int PS_make_palette (t_sm_palette *palette)
{
    if (palette == NULL) {
        return 0;  /* postscript can do continuous colors */
    }

    PS_make_header(palette);
    return 0;
}


TERM_PUBLIC void PS_set_color (double gray)
{
/* map [0;1] to gray/colors */
    if (gray <= 0)
	fputs( "0 g ", gpoutfile ); 
    else {
	if (gray >= 1)
	    fputs( "1 g ", gpoutfile ); 
	else
	    fprintf( gpoutfile, "%s g ", save_space(gray) );
    }
    PS_relative_ok = FALSE; /* "M" required because "g" forces stroke (??) */
}


TERM_PUBLIC void PS_filled_polygon ( int points, gpiPoint *corners )
{
    /* Stroke the previous graphic element if required. */
    if (PS_relative_ok)
	PS_FLUSH_PATH;

    /* produce lines like:
       9055 29350 N 695 0 V 0 564 V -695 0 h  ... for quadrangles
       9055 29350 N 695 0 V 0 564 f           ... otherwise
     */
    fprintf(gpoutfile, "%i %i N", corners[0].x, corners[0].y);
    if (points == 4) /* shorter version for quadrangles */
	fprintf(gpoutfile, " %i %i %i %i %i %i h\n",
	    corners[3].x-corners[2].x, corners[3].y-corners[2].y,
	    corners[2].x-corners[1].x, corners[2].y-corners[1].y,
	    corners[1].x-corners[0].x, corners[1].y-corners[0].y
	       );
    else {  
	int i;
	for (i = 1; i < points-1; i++)
	    fprintf(gpoutfile, " %i %i V",
		corners[i].x-corners[i-1].x, corners[i].y-corners[i-1].y);
	fprintf(gpoutfile, " %i %i f\n",
	    corners[i].x-corners[i-1].x, corners[i].y-corners[i-1].y);
    }
    PS_relative_ok = FALSE;
}

TERM_PUBLIC void PS_previous_palette(void)
{
    /* Needed to stroke the previous graphic element. */
    PS_FLUSH_PATH;
    fprintf(gpoutfile, "grestore %% colour palette end\n");
}

#endif /* PM3D */

static void
delete_ps_fontfile(prev, this)
struct ps_fontfile_def *prev, *this;
{
    if (this != NULL) {		/* there really is something to delete */
	printf("hallo1\n");
	if (prev != NULL)	/* there is a previous ps_fontfile */
	    prev->next = this->next;
	else			/* this = first_ps_fontfile so change first_ps_fontfile */
	    first_ps_fontfile = this->next;
	free(this->fontfile_name);
	free(this->fontfile_fullname);
	free(this);
	this = NULL;
    }
}

#endif /* TERM_BODY */

#ifdef TERM_TABLE

TERM_TABLE_START(post_driver)
"postscript",
"PostScript graphics language [mode \042fontname\042 font_size]",
   PS_XMAX, PS_YMAX, PS_VCHAR, PS_HCHAR, 
   PS_VTIC, PS_HTIC, PS_options, PS_init, PS_reset, 
   PS_text, null_scale, PS_graphics, PS_move, PS_vector, 
   PS_linetype, PS_put_text, PS_text_angle, 
   PS_justify_text, PS_point, do_arrow, PS_set_font, PS_pointsize,
   TERM_BINARY|TERM_IS_POSTSCRIPT /*flags*/, 
   0 /*suspend*/, 0 /*resume*/, PS_fillbox, PS_linewidth
#ifdef USE_MOUSE
   , 0, 0, 0, 0, 0 /* no mouse support for postscript */
#endif
#ifdef PM3D
   , PS_make_palette,
   PS_previous_palette, /* write grestore */
   PS_set_color,
   PS_filled_polygon
#endif /* PM3D */
   , ENHPS_OPEN, ENHPS_FLUSH, ENHPS_WRITEC
TERM_TABLE_END(post_driver)

#undef LAST_TERM
#define LAST_TERM post_driver

#endif /* TERM_TABLE */

#endif /* TERM_PROTO_ONLY */

#ifdef TERM_HELP
START_HELP(post)
"1 postscript",
"?commands set terminal postscript",
"?set terminal postscript",
"?set term postscript",
"?terminal postscript",
"?term postscript",
"?postscript",
" Several options may be set in the `postscript` driver.",
"",
" Syntax:",
"       set terminal postscript {<mode>} {enhanced | noenhanced}",
"                               {color | colour | monochrome}",
"                               {blacktext | colortext | colourtext}",
"                               {solid | dashed} {dashlength | dl <DL>}",
"                               {linewidth | lw <LW>}",
"                               {<duplexing>}",
"                               {rounded | butt}",
"                               {fontfile [add | delete] \"<filename>\"}",
"                               {palfuncparam <samples>{,<maxdeviation>}}",
"                               {\"<fontname>\"} {<fontsize>}",
"",
" where <mode> is `landscape`, `portrait`, `eps` or `default`;",
" `enhanced` enables enhanced text mode features (subscripts,",
" superscripts and mixed fonts). See `enhanced` for more information.",
" Option `color` enables color;",
" `blacktext` forces all text to be written in black even in color mode;",
" `solid` draws all plots with solid lines, overriding any dashed patterns;",
" `dashlength` or `dl` scales the length of the dashed-line segments by <DL>",
" (which is a floating-point number greater than zero);",
" `linewidth` or `lw` scales all linewidths by <LW>;",
" <duplexing> is `defaultplex`, `simplex` or `duplex` (\"duplexing\" in",
" PostScript is the ability of the printer to print on both sides of the same",
" page---don't set this if your printer can't do it);",
" `rounded` sets line caps and line joins to be rounded; `butt` is the",
" default, butt caps and mitered joins;",
" `\"<fontname>\"` is the name of a valid PostScript font; and `<fontsize>` is",
" the size of the font in PostScript points.",
" In addition to the standard postscript fonts, an oblique version of the",
" Symbol font, useful for mathematics, is defined. It is called"
" \"Symbol-Oblique\".",
"",
" `default` mode sets all options to their defaults: `landscape`, `monochrome`,",
" `dashed`, `dl 1.0`, `lw 1.0`, `defaultplex`, `noenhanced`, \"Helvetica\" and",
" 14pt.  Default size of a PostScript plot is 10 inches wide and 7 inches high.",
"",
" `palfuncparam` is only available if compiled with `pm3d` support.  It controls",
" how `set palette functions` are encoded as gradients in the output.",
" Analytic color component functions (set via `set palette functions`) are",
" encoded as linear interpolated gradients in the postscript output:  The color",
" component functions are sampled at <samples> points and all points are",
" removed from this gradient which can be removed without changing the",
" resulting colors by more than <maxdeviation>.  For almost every useful",
" palette you may savely leave the defaults of <samples>=2000 and",
" <maxdeviation>=0.003 untouched.",
"",
" `eps` mode generates EPS (Encapsulated PostScript) output, which is just",
" regular PostScript with some additional lines that allow the file to be",
" imported into a variety of other applications.  (The added lines are",
" PostScript comment lines, so the file may still be printed by itself.)  To",
" get EPS output, use the `eps` mode and make only one plot per file.  In `eps`",
" mode the whole plot, including the fonts, is reduced to half of the default",
" size.",
"",
" Fonts listed by `fontfile` or `fontfile add` encapsulate the font",
" definitions of the listed font from a postscript Type 1 or TrueType font",
" file directly into the gnuplot output postscript file. Thus, the enclosed",
" font can be used in labels, titles, etc. See the section",
" `postscript fontfile` for more details.",
" With `fontfile delete` a fontfile is deleted from the list of embedded",
" files.",
"",
" Examples:",
"       set terminal postscript default       # old postscript",
"       set terminal postscript enhanced      # old enhpost",
"       set terminal postscript landscape 22  # old psbig",
"       set terminal postscript eps 14        # old epsf1",
"       set terminal postscript eps 22        # old epsf2",
"       set size 0.7,1.4; set term post portrait color \"Times-Roman\" 14",
"       set term post \"VAGRoundedBT_Regular\" 14 fontfile \"bvrr8a.pfa\"",
"",
" Linewidths and pointsizes may be changed with `set style line`.",
"",
" The `postscript` driver supports about 70 distinct pointtypes, selectable",
" through the `pointtype` option on `plot` and `set style line`.",
"",
" Several possibly useful files about `gnuplot`'s PostScript are included",
" in the /docs/psdoc subdirectory of the `gnuplot` distribution and at the",
" distribution sites.  These are \"ps_symbols.gpi\" (a `gnuplot` command file",
" that, when executed, creates the file \"ps_symbols.ps\" which shows all the",
" symbols available through the `postscript` terminal), \"ps_guide.ps\" (a",
" PostScript file that contains a summary of the enhanced syntax and a page",
" showing what the octal codes produce with text and symbol fonts),",
" \"ps_file.doc\" (a text file that contains a discussion of the organization",
" of a PostScript file written by `gnuplot`), and \"ps_fontfile_doc.tex\"",
" (a LaTeX file which contains a short documentation concerning the",
" encapsulation of LaTeX fonts with a glyph table of the math fonts).",
"", 
" A PostScript file is editable, so once `gnuplot` has created one, you are",
" free to modify it to your heart's desire.  See the `editing postscript`",
" section for some hints.",
"2 enhanced postscript",
"?commands set terminal postscript enhanced",
"?set terminal postscript enhanced",
"?set term postscript enhanced",
"?terminal postscript enhanced",
"?term postscript enhanced",
"?enhanced_postscript",
"?enhanced postscript",
"?Enhanced postscript",
"?enhanced text",
"?Enhanced text",
"?enhanced",
" Several terminal types support an enhanced text mode in which ",
" additional formatting information is embedded in the text string.",
"",
"@start table - first is interactive cleartext form",
"  Control      Examples        Explanation",
"   ^           a^x             superscript",
"   _           a_x             subscript",
"   @           @x or a@^b_c    phantom box (occupies no width)",
"   &           &{space}        inserts space of specified length",
"   ~           ~a{.8-}         overprints '-' on 'a', raised by .8",
"                               times the current fontsize",
"#\\begin{tabular}{|ccl|} \\hline",
"#\\multicolumn{3}{|c|}{Enhanced Text Control Codes} \\\\ \\hline",
"#Control & Examples & Explanation \\\\ \\hline",
"#\\verb~^~ & \\verb~a^x~ & superscript\\\\",
"#\\verb~_~ & \\verb~a_x~ & subscript\\\\",
"#\\verb~@~ & \\verb~@x or a@^b_c~ & phantom box (occupies no width)\\\\",
"#\\verb~&~ & \\verb~&{space}~ & inserts space of specified length\\\\",
"#\\verb|~| & \\verb|~a{.8-}| & overprints '-' on 'a', raised by .8\\\\",
"#\\verb~ ~ & \\verb~ ~ & times the current fontsize\\\\",
"%c c l .",
"%.TE", /* ugly - doc2ms uses @ for column separator, but here we */
"%.TS", /* need @ in table, so end and restart the table ! */
"%center box tab ($) ;",
"%c c l .",
"%Control$Examples$Explanation",
"%_",
"%^$a^x$superscript",
"%\\&_$a\\&_x$subscript",
"% @ $ @x or a\\&@^b\\&_c$phantom box (occupies no width)",
"% & $ &{space}$inserts space of specified length",
"% ~ $ ~a{.8-}$overprints '-' on 'a', raised by .8",
"%   $   $times the current fontsize",
"@end table",
"",
" Braces can be used to place multiple-character text where a single character",
" is expected (e.g., 2^{10}).  To change the font and/or size, use the full",
" form:  {/[fontname][=fontsize | *fontscale] text}.  Thus {/Symbol=20 G} is a",
" 20-point GAMMA and {/*0.75 K} is a K at three-quarters of whatever fontsize",
" is currently in effect.  (The '/' character MUST be the first character after",
" the '{'.)",
"",
" If the encoding vector has been changed by `set encoding`, the default",
" encoding vector can be used instead by following the slash with a dash.  This",
" is unnecessary if you use the Symbol font, however---since /Symbol uses its",
" own encoding vector, `gnuplot` will not apply any other encoding vector to",
" it.",
"",
" The phantom box is useful for a@^b_c to align superscripts and subscripts",
" but does not work well for overwriting an accent on a letter.  (To do the",
" latter, it is much better to use 'set encoding iso_8859_1' to change to the",
" ISO Latin-1 encoding vector, which contains a large variety of letters with",
" accents or other diacritical marks.)  Since the box is non-spacing, it is",
" sensible to put the shorter of the subscript or superscript in the box (that",
" is, after the @).",
"",
" Space equal in length to a string can be inserted using the '&' character.",
" Thus",
"         'abc&{def}ghi'",
" would produce",
"         'abc   ghi'.",
"",
" The '~' character causes the next character or bracketed text to be",
" overprinted by the following character or bracketed text.  The second text",
" will be horizontally centered on the first.  Thus '~a/' will result in an 'a'",
" with a slash through it.  You can also shift the second text vertically by",
" preceding the second text with a number, which will define the fraction of the",
" current fontsize by which the text will be raised or lowered.  In this case",
" the number and text must be enclosed in brackets because more than one",
" character is necessary.  If the overprinted text begins with a number, put a",
" space between the vertical offset and the text ('~{abc}{.5 000}'); otherwise",
" no space is needed ('~{abc}{.5---}').  You can change the font for one or",
" both strings ('~a{.5 /*.2 o}'---an 'a' with a one-fifth-size 'o' on top---and",
" the space between the number and the slash is necessary), but you can't",
" change it after the beginning of the string.  Neither can you use any other",
" special syntax within either string.  You can, of course, use control",
" characters by escaping them (see below), such as '~a{\\^}'",
"",
" You can access special symbols numerically by specifying \\character-code (in",
" octal), e.g., {/Symbol \\245} is the symbol for infinity.",
"",
" You can escape control characters using \\, e.g.,  \\\\, \\{, and so on.",
"",
" But be aware that strings in double-quotes are parsed differently than those",
" enclosed in single-quotes.  The major difference is that backslashes may need",
" to be doubled when in double-quoted strings.",
"",
" Examples (these are hard to describe in words---try them!):",
"       set xlabel 'Time (10^6 {/Symbol m}s)'",
"       set title '{/Symbol=18 \\362@_{/=9.6 0}^{/=12 x}} \\",
"                  {/Helvetica e^{-{/Symbol m}^2/2} d}{/Symbol m}'",
"",
" The file \"ps_guide.ps\" in the /docs/psdoc subdirectory of the `gnuplot` source",
" distribution contains more examples of the enhanced syntax.",
"2 editing postscript",
"?commands set terminal postscript editing",
"?set terminal postscript editing",
"?set term postscript editing",
"?terminal postscript editing",
"?term postscript editing",
"?editing_postscript",
"?editing postscript",
" The PostScript language is a very complex language---far too complex to",
" describe in any detail in this document.  Nevertheless there are some things",
" in a PostScript file written by `gnuplot` that can be changed without risk of",
" introducing fatal errors into the file.",
"",
" For example, the PostScript statement \"/Color true def\" (written into the",
" file in response to the command `set terminal postscript color`), may be",
" altered in an obvious way to generate a black-and-white version of a plot.",
" Similarly line colors, text colors, line weights and symbol sizes can also be",
" altered in straight-forward ways.  Text (titles and labels) can be edited to",
" correct misspellings or to change fonts.  Anything can be repositioned, and",
" of course anything can be added or deleted, but modifications such as these",
" may require deeper knowledge of the PostScript language.",
"",
" The organization of a PostScript file written by `gnuplot` is discussed in",
" the text file \"ps_file.doc\" in the docs/ps subdirectory of the gnuplot",
" source distribution.",
"2 postscript fontfile",
"?commands set terminal postscript fontfile",
"?set terminal postscript fontfile",
"?set term postscript fontfile",
"?terminal postscript fontfile",
"?term postscript fontfile",
"?postscript fontfile",
"?fontfile",
" The `fontfile` or `fontfile add` option takes one file name as argument",
" and encapsulates this file into the postscript output in order to make",
" this font available for text elements (labels, tic marks, titles, etc.).",
" The `fontfile delete` option also takes one file name as argument. It",
" deletes this file name from the list of encapsulated files.",
"",
" The postscript terminal understands some",
" font file formats: Type 1 fonts in ASCII file format (extension \".pfa\"),",
" Type 1 fonts in binary file format (extension \".pfb\"), and TrueType",
" fonts (extension \".ttf\"). Pfa files are understood directly, pfb and ttf",
" files are converted on the fly if appropriate conversion tools are",
" installed (see below). You have to specify the full filename with the",
" extension. Each `fontfile` option takes exact one font file name. This",
" option can be used multiple times in order to include more than one font",
" file.",
"",
" The font file is searched in the working directory and in all directories",
" listed in the fontpath which is determined by `set fontpath`.",
" In addition, the fontpath can be set using the environment variable",
" GNUPLOT_FONTPATH. If this is not set a system dependent default search",
" list is used. See `set fontpath` for more details.",
"",
" For using the encapsulated font file you have to specify the font name",
" (which normally is not the same as the file name). When embedding a",
" font file by using the `fontfile` option in interactive mode, the ",
" font name is printed on the screen. E.g.",
"    Font file 'p052004l.pfb' contains the font 'URWPalladioL-Bold'. Location:",
"    /usr/lib/X11/fonts/URW/p052004l.pfb",
"",
" When using pfa or pfb fonts, you can also find it out by looking into the",
" font file. There is a line similar to \"/FontName /URWPalladioL-Bold def\".",
" The middle string without the slash is the fontname, here",
" \"URWPalladioL-Bold\".",
" For TrueType fonts, this is not so easy since the font name is stored in a",
" binary format. In addition, they often have spaces in the font names which",
" is not supported by Type 1 fonts (in which a TrueType is converted on the",
" fly). The font names are changed in order to eliminate the spaces in the",
" fontnames. The easiest way to find out which font name is generated for",
" use with gnuplot, start gnuplot in interactive mode and type in",
" \"set terminal postscript fontfile '<filename.ttf>'\".",
"",
" For converting font files to pfa format the conversion tool has to read",
" the font from a file and write it to standard output.",
" For pfb files \"pfbtops\" is a tool which can do this. If this program",
" is installed on your system the on the fly conversion should work.",
" Just try to encapsulate a pfb file. If the compiled in program call does",
" not work correctly you can specify how this program is called by",
" defining the environment variable GNUPLOT_PFBTOPFA e.g. to",
" \"pfbtops %s\". The `%s` will be repeated by the font file name and thus",
" has to exist in the string.",
" If you don't want to do the conversion on the fly but get a pfa file of",
" the font you can use the tool \"pfb2pfa\" which is written in simple c",
" and should compile with any c compiler.",
" It is available from many ftp servers, e.g.",
"^ <a href=\"ftp://ftp.dante.de/tex-archive/fonts/utilities/ps2mf/\">",
"           ftp://ftp.dante.de/tex-archive/fonts/utilities/ps2mf/",
"^ </a>",
" In fact, \"pfbtopfa\" and \"pfb2ps\" do the same job. \"pfbtopfa\" puts",
" the resulting pfa code into a file, whereas \"pfbtops\" writes it to",
" standard output.",
"",
" TrueType fonts are converted into Type 1 pfa format, e.g.",
" by using the tool \"ttf2pt1\" which is available from",
"^ <a href=\"http://ttf2pt1.sourceforge.net/\">",
"           http://ttf2pt1.sourceforge.net/",
"^ </a>",
" If the builtin conversion does not",
" work, the conversion command can be changed by the environment variable",
" GNUPLOT_TTFTOPFA. For usage with ttf2pt1 it may be set to",
" \"ttf2pt1 -a -e -W 0 %s - \". Here again, `%s` stands for the",
" file name.",
"",
" For special purposes you also can use a pipe (if available for your",
" operating system). Therefore you start the file name definition with ",
" the character \"<\" and append a program call. This program has ",
" to write pfa data to standard output. Thus, a pfa file may be accessed",
" by `set fontfile \"< cat garamond.pfa\"`.",
"",
" For example, including Type 1 font files can be used for including the",
" postscript output in LaTeX documents. The \"european computer modern\"",
" font (which is a variant of the \"computer modern\" font) is available",
" in pfb format from any CTAN server, e.g.",
"^ <a href=\"ftp://ftp.dante.de/tex-archive/fonts/ps-type1/cm-super/\">",
"           ftp://ftp.dante.de/tex-archive/fonts/ps-type1/cm-super/",
"^ </a>",
" For example, the file \"sfrm1000.pfb\" contains the normal upright fonts",
" with serifs in the design size 10pt (font name \"SFRM1000\").",
" The computer modern fonts, which are still necessary for mathematics,",
" are available from",
"^ <a href=\"ftp://ftp.dante.de/tex-archive/fonts/cm/ps-type1/bluesky\">",
"           ftp://ftp.dante.de/tex-archive/fonts/cm/ps-type1/bluesky",
"^ </a>",
" With these you can use any character available in TeX. However, the",
" computer modern fonts have a strange encoding. (This is why you should not",
" use cmr10.pfb for text, but sfrm1000.pfb instead.)",
" The usage of TeX fonts is shown in one of the demos.",
" The file \"ps_fontfile_doc.tex\" in the /docs/psdoc subdirectory of the",
" `gnuplot` source distribution contains a table with glyphs of the TeX",
" mathfonts.",
"",
" If the font \"CMEX10\" is embedded (file \"cmex10.pfb\") gnuplot defines",
" the additional font \"CMEX10-Baseline\". It is shifted vertically in order",
" to fit better to the other glyphs (CMEX10 has its baseline at the top of",
" the symbols)."
END_HELP(post)
#endif /* TERM_HELP */
